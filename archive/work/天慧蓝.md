# 排行榜项目

## 项目架构

**技术栈**

+ Spirng,SpringMVC,SpringBoot,MyBatis,MyBatisPlus,Redis,MySQL,RocketMQ

**项目功能**

+ 实现日周月三类排行

**项目实现细节**

+ 前端获取：先查caffeine（保存可以直接返回给前端的排行榜详细数据），查不到再查redis（保存每个排行榜下文章id和点击量），再去mysql查询详细数据
+ rocketmq传递过来的消息保存文章id和用户id，排行榜项目只记录点击量，另一个服务记录用户浏览记录

## 新思考

### 其他排行榜实现思路

**区间排序树**

要想知道某个用户的名次，只需要知道比这个用户高分的人数，不一定需要对积分做排序

在这里换个思路不对积分进行排序，仅仅是统计每个积分区间的人数，用积分区间的形式去统计相应的人数，下面是算法描述

根据积分范围创建平衡二叉树。设[0, N]为积分范围， 构造的平衡二叉树如下图

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202402051645188.jpeg)

每个节点包含两个数据字段（除了指针）：

Range: 表示积分范围。

Counts： 表示当前积分区间包含多少人

积分的区间的划分是根据平分的方式，把当前积分范围一分为二生成两个子节点，然后递归的重复该步骤，直到积分区间无法划分为止（即区间[x, y]， x == y）

这种思想二分查找和二叉查找树类似。比如，需要查找一个积分为490000数据的排名，那么在是属于一级区间的[0,500000)当中的，那么的它的排名应该在[500000,1000000]count个用户后面，所以它的排名应该+= count ,然后继续往[0,500000]的右子树区间[250000,500000]查找，它在右子树，排名在[0,250000)用户前面，故不需要+=count，类似继续往下，直到[490000,490001)区间，就是这个数据的排名了

### 最近N期榜（滚动）

#### 方案1：每日一个滚动榜，当日离线补齐数据

还以日榜为例，最近N天榜就是把前N-1天到当天的每一个日榜榜单累加即可，比如最近7天榜，就是前6天到当天的每一个日榜中相同元素数据累加。因此，最直观的一个方案是：首先记录每天的排行榜R，那么第i天的最近N天榜Si=∑N−1n=0Ri−n，其中，Ri−x表示第i天的前x天的日榜。实现上，可以每日生成一个滚动榜S和当天日榜R，加分时同时写入S和R，每日零点后跑工具将前N-1天数据累加写入当日滚动榜S。  

这个方案的优点是直观，实现简单。但缺点也很明显，一是每日一个滚动榜，消耗内存较多；二是数据更新不实时，需要等待离线作业完成累加后S中的数据才完全正确；三是时间复杂度高，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受。  

#### 方案2：全局一个滚动榜，当日离线补齐数据

基于方案1，如果业务无需查询历史的S，可以只使用全局一个S，无需每日创建一个Si。加分操作还是同时加当日的Ri和全局唯一的S，但每日零点的离线作业改为从S中减去Ri−(N−1)的数据（即将最早一天的数据淘汰，从而实现S的计数滚动）。  

此方案减少了内存使用，同时离线任务每次只需读取一个日榜做减法，时间复杂度为O(1)；但仍需要离线作业完成才能保证数据正确性，还是无法做到平滑过渡。  

#### 方案3：每日一个滚动榜，实时更新

要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是预写未来的榜单。不难得出，当日分数会计入往后N-1天的滚动榜中。因此，可以写当天的滚动榜Si的同时，写往后N-1天的榜单Si+1到Si+N−1。  

该方案不仅能脱离离线作业做到实时更新，且可以省略每天的日榜。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，写入量小时还勉强能接受，如果写操作量大或者需要的是30天、60天滚动榜，此方案可行性几乎为零。

#### 方案4：实时更新，常数次写操作

有不有办法做到既能实时更新，写榜数量也不随N的增加而增加呢？不难看出，第i天滚动榜Si=∑N−1n=0Ri−n，而第i+1天的滚动榜Si+1=∑N−1n=0R(i+1)−n=∑N−2n=0Ri−n+Ri+1。显然，Si+1=Si−Ri−(N−1)+Ri+1。由于Ri+1在刚达到零点时必然为空且可以在次日实时加到Si+1上，因此如果我们能提前准备好Si−Ri−(N−1)这部分数据，那么在零点进入i+1天后，Ri+1自然就是可用状态了

```lua
以3天滚动榜为例，次日滚动榜初始态为当日滚动榜减去n-2天的日榜数据。
     +-------------------------------------------+
     |                                           |
+----+---+   +--------+   +--------+             |
|        |   |        |   |        |             |
| R(i-2) |   | R(i-1) |   |  R(i)  |             |
|        |   |        |   |        |             |
+----+---+   +----+---+   +---+----+             |
     |            |           |                  |
     |            |           |                  |
     |            |           |                  |
     |            |           v+                 v-
     |            |
     |            |    +  +--------+        +--------+
     |            +-----> |        |     +  |        |
     |                 +  |  S(i)  | +---+> | S(i+1) |
     +-----------------+> |        |        |        |
                          +--------+        +--------+
```

那么，如何提前准备好Si−Ri−(N−1)这部分数据呢？可以如下处理：

- 对一个元素加分时，加当日周期榜Ri、滚动榜Si；还需根据其在今日滚动榜中的分数s、及n-1天日榜中的分数r，计算出其在明日滚动榜中的初始分数`s-r`写入明日滚动榜中；即3个写操作；
- 如果一个元素在当日没有任何加分操作，那么不会触发写入初始分数操作，所以还需要一个离线工具补齐。与方案1、2不同的是，该离线工具可提前一天运行，即当日运行离线工具补齐次日的滚动榜数据即可。  

简而言之：第一步是运行离线工具生成次日的滚动榜；第二步是在写操作时同时更新次日的滚动榜。  

该方案也是每日一个滚动榜。相对方案3而言，是空间换时间。如果空间不足且无保留历史的需求，可在离线工具中清理历史数据

```lua
                                +--------------+
                                |              |
                                |   AddScore   |
                                |              |
                                +-+----+-----+-+
                                  |    |     |
                                  v    |     |
+--------+   +--------+   +-------++   |     |
|        |   |        |   |        |   |     |
| R(i-2) |   | R(i-1) |   |  R(i)  |   |     |
|        |   |        |   |        |   |     |
+--------+   +--------+   +--------+   |     |
                                       |     v
                          +--------+   |    ++-------+
                          |        |   |    |        |
                          |  S(i)  +<--+    | S(i+1) |
                          |        |        |        |
                          +--------+        +----+---+
                                                 ^
                                                 |
                                                 |
                                          +------+-----+
                                          |            |
                                          |    Tool    |
                                          |            |
                                          +------------+
```

#### 方案4的实现

以下是实现参考。此处仅列出核心的lua脚本。Redis命令调用脚本的参数定义为

```lua
eval script 4 当日日榜key 当日滚动榜key 即将淘汰的日榜key 明日滚动榜key 榜单元素名 加分数
```

lua脚本script如下

```lua
--加今日日榜分数
redis.call('ZINCRBY', KEYS[1], ARGV[2], ARGV[1])

--加今日滚动榜分数
local rs = redis.call('ZINCRBY', KEYS[2], ARGV[2], ARGV[1])
local curRoundScore = 0
if (rs) then
    curRoundScore = tonumber(rs)
end

--取即将淘汰的日榜分数
rs = redis.call('ZSCORE', KEYS[3], ARGV[1])
local oldCycleScore = 0
if (rs) then
    oldCycleScore = tonumber(rs)
end

--计算次日滚动榜初始分数
local nextRoundScore = curRoundScore - oldCycleScore
if nextRoundScore < 0 then
    nextRoundScore = 0
end

--设置次日滚动榜分数
redis.call('ZADD', KEYS[4], nextRoundScore, ARGV[1])

--返回今日分数
rs = redis.call('ZREVRANK', KEYS[2], ARGV[1])
return {curRoundScore, rs}
```

**关于榜单key计算准确度的探讨**：我们的业务是在排行榜接入层逻辑中计算榜单后缀的，这种方案对逻辑层多台机器的时间一致性要求较高，如果逻辑层[服务器](https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065)时钟不一致，可能在时间切换点上出现不同机器读写不同榜单的问题。如果业务对时间精确度要求严格，可以考虑通过lua脚步在redis端计算后缀

**关于内存容量限制的探讨**：基于ZSet实现的排行榜，每个元素约需要100字节内存。如果榜单长度为1000万，则每个榜单约需要1G内存。滚动榜的计算需要每日保留一个日榜，如果滚动周期较长，则可能单机内存容量不足以容纳所有需要的榜单。 考虑到历史日榜数据是不会变更的，因此不在lua脚本中读取历史日榜数据也无一致性问题。故可以将榜单打散到多个Redis实例，在接入层做逻辑读取历史日榜的分数，再以参数形式传入给lua脚本处理

[基于Redis实现排行榜周期榜与最近N期榜](https://cloud.tencent.com/developer/article/1370111)

### 一二级缓存一致性解决方案

+ redis中统计每类排行榜前十个文章总点击量，每次某排行榜点击量修改之后，都需要去对比并更新该数值，如果该数值有变化，需要通知分布式部署下该项目对应下的caffeine，修改其对应排行榜内容
+ 通知操作可以使用redis的发布/订阅机制、rocketmq、观察者模式都可以

### 实现页面的数据保鲜

+ 前端通过定时器实现定时刷新页面，获取最新数据
+ 观察者模式