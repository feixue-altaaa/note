# 并发基础

## 并发编程三要素是什么？

- 原子性：指的是一个操作不能再继续拆分，要么一次操作完成，要么就是不执行；
- 可见性：指的是一个变量在被一个线程更改后，其他的线程能立即看到最新的值；
- 有序性：指的是程序的执行按照代码的先后顺序执行

至于为什么会提出这三个要素，我理解这是因为 Java 编程中如果满足了这 3 个特性，程序的并发操作就是线程安全的

对于关键字 synchronized，即保证了原子性，也保证了可见性和有序性。而关键字 volatile 无法保证原子性

## 脏读、不可重复读、幻读

### 脏读（读取未提交数据）
- A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读
- 这种情况常发生于转账与取款操作中

| 时间顺序 | 转账事务                                          | 取款事务                                         |
| -------- | ------------------------------------------------- | ------------------------------------------------ |
| 1        |                                                   | 开始事务                                         |
| 2        | 开始事务                                          |                                                  |
| 3        |                                                   | 查询账户余额为2000元                             |
| 4        |                                                   | 取款1000元，余额被更改为1000元                   |
| 5        | 查询账户余额为1000元（产生脏读）                  |                                                  |
| 6        |                                                   | 取款操作发生未知错误，事务回滚，余额变更为2000元 |
| 7        | 转入2000元，余额被更改为3000元（脏读的1000+2000） |                                                  |
| 8        | 提交事务                                          |                                                  |

### 不可重复读（前后多次读取，数据内容不一致）

+ 事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读

| 时间顺序 | 事务A                        | 事务B                |
| -------- | ---------------------------- | -------------------- |
| 1        | 开始事务                     |                      |
| 2        | 第一次查询，小明的年龄为20岁 |                      |
| 3        |                              | 开始事务             |
| 4        | 其他操作                     |                      |
| 5        |                              | 更改小明的年龄为30岁 |
| 6        |                              | 提交事务             |
| 7        | 第二次查询，小明的年龄为30岁 |                      |

### [幻读](https://so.csdn.net/so/search?q=幻读&spm=1001.2101.3001.7020)（前后多次读取，数据总量不一致）

+ 事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读

| 时间顺序 | 事务A                       | 事务B         |
| -------- | --------------------------- | ------------- |
| 1        | 开始事务                    |               |
| 2        | 第一次查询，数据总量为100条 |               |
| 3        |                             | 开始事务      |
| 4        | 其他操作                    |               |
| 5        |                             | 新增100条数据 |
| 6        |                             | 提交事务      |
| 7        | 第二次查询，数据总量为200条 |               |

#  线程和线程池

## 线程

### 进程与线程的区别总结

- 线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程
- 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
- 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小
- 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程
- 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮
- 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191105205545651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

> ### 程序计数器为什么是私有的?
>
> 程序计数器主要有下面两个作用
>
> - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
> - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪

> ### 虚拟机栈和本地方法栈为什么是私有的?
>
> - 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程
> - 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务
>
> 为了**保证线程中的局部变量不被别的线程访问到**

### **多线程提高CPU使用率**

![多线程](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlQjklQjYlRTUlOEYlOTElRTclQkMlOTYlRTclQTglOEItJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2LyVFNSVBNCU5QSVFNyVCQSVCRiVFNyVBOCU4Qi5wbmc?x-oss-process=image/format,png)

### 协程

**进程和线程的痛点**

- 线程之间是如何进行协作的呢？

- 最经典的例子就是**生产者/消费者模式**

- 若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据


![img](http://5b0988e595225.cdn.sohucs.com/images/20180622/a83040de2d0b491e9e445d981870099a.png)

如何用java语言实现生产者/消费者模式呢？

```java
public class ProducerConsumerTest {
 
	public static void main(String args[]) {
		final Queue<Integer> sharedQueue = new Queue();
		Thread producer = new Producer(sharedQueue);
		Thread consumer = new Consumer(sharedQueue);
		producer.start();
		consumer.start();
	}
}
```

```java
class Producer extends Thread {
 
	private static final int MAX_QUEUE_SIZE = 5;
 
	private final Queue sharedQueue;
 
	public Producer(Queue sharedQueue) {
		super();
		this.sharedQueue = sharedQueue;
	}
 
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (sharedQueue) {
				while (sharedQueue.size() >= MAX_QUEUE_SIZE) {
					System.out.println("队列满了，等待消费");
					try {
						sharedQueue.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				sharedQueue.add(i);
				System.out.println("进行生产 : " + i);
				sharedQueue.notify();
			}
		}
	}
}
```

```java
class Consumer extends Thread {
	private final Queue sharedQueue;
 
	public Consumer(Queue sharedQueue) {
		super();
		this.sharedQueue = sharedQueue;
	}
 
	@Override
	public void run() {
		while (true) {
			synchronized (sharedQueue) {
				while (sharedQueue.size() == 0) {
					try {
						System.out.println("队列空了，等待生产");
						sharedQueue.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				int number = sharedQueue.poll();
				System.out.println("进行消费 : " + number);
				sharedQueue.notify();
			}
		}
	}
}
```

这段代码做了下面几件事

- 1.定义了一个生产者类，一个消费者类。
- 2.生产者类循环100次，向同步队列当中插入数据。
- 3.消费者循环监听同步队列，当队列有数据时拉取数据。
- 4.如果队列满了（达到5个元素），生产者阻塞。
- 5.如果队列空了，消费者阻塞。

上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下

- **涉及到同步锁**
- **涉及到线程阻塞状态和可运行状态之间的切换**
- **涉及到线程上下文的切换**

![img](http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg)

- 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）
- 线程的内存在MB级别，而协程只需要KB级别
- 这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源，**协程的开销远远小于线程的开销**

> Java语言并没有对协程的原生支持，但是某些开源框架模拟出了协程的功能，可以看一看**Kilim框架**

### Java 线程有几种状态？

在 Java 中，线程主要分为六种状态

- 初始（NEW）：新创建了一个线程对象，但还没有调用 start() 方法；
- 运行（RUNNABLE）：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”；线程对象创建后，其它线程（如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU的 使用权，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）
- 阻塞（BLOCKED）：表示线程阻塞于锁；
- 等待（WAITING）：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）；
- 超时等待（TIMED_WAITING）：该状态不同于 WAITING，它可以在指定的时间后自行返回；
- 终止（TERMINATED）：表示该线程已经执行完毕

### Java 线程状态是如何切换的

![img](https://img-blog.csdn.net/2018070117435683?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> ## sleep( )、wait()、join( )、yield( )的区别
>
> ### Sleep V.S wait
>
> #### sleep
>
> 线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。 sleep() 使当前线程进入阻塞状态，在指定时间内不会执行
>
> #### wait
>
> Object 类的方法，对此对象调用 wait 方法导致本线程放弃对象锁，进入等待 此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象 锁定池准备获得对象锁进入运行状态。
>
> #### 区别比较
>
> - 这两个方法来自不同的类分别是 Thread 和 Object 
>
> - 最主要是 sleep 方法没有释放锁，而 wait 方法释放了锁，使得其他线程可以使用同 步控制块或者方法
>
> - wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可 以在任何地方使用(使用范围) 
>
> - sleep 必须捕获异常，而 wait，notify 和 notifyAll 不需要捕获异常
>
>   - sleep 方法属于 Thread 类中方法，表示让一个线程进入睡眠状态，等待一定的时 间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程 的运行也需要时间，一个线程对象调用了 sleep 方法之后，并不会释放他所持有的所有对象 锁，所以也就不会影响其他进程对象的运行。但在 sleep 的过程中过程中有可能被其他对象 调用它的 interrupt(),产生 InterruptedException 异常，如果你的程序不捕获这个异常，线程 就会异常终止，进入 TERMINATED 状态，如果你的程序捕获了这个异常，那么程序就会继 续执行 catch 语句块(可能还有 finally 语句块)以及以后的代码。sleep()方法是静态方法，也就是说他只对当前对象有效，通过 t.sleep()让 t 对象进入 sleep，这样的做法是错误的，它只会是使当前线程被 sleep 而不是 t 线程 
>
>   - wait 属于 Object 的成员方法，一旦一个对象调用了 wait 方法，必须要采用 notify() 和 notifyAll()方法唤醒该进程;如果线程拥有某个或某些对象的同步锁，那么在调用了 wait() 后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了 wait()方法的对象。 wait()方法也同样会在 wait 的过程中有可能被其他对象调用 interrupt()方法而产生
>
> ### yield()
>
> 停止当前线程，让同等优先权的线程或更高优先级的线程有执行的机会。 如果没有的话，那么 yield()方法将不会起作用，并且由可执行状态后马上又被执行。
>
> ### join
>
> 用于在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执 行结束后，再继续执行当前线程。如：t.join();//主要用于等待 t 线程运行结束，若无此句， main 则会执行完毕，导致结果不可预测

### Java线程通信

> ### 为什么需要线程通信
>
> 线程通信就是当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺
>
> 线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步的执行，但是如果每个线程间都孤立的运行，那就会造资源浪费。所以在现实中，我们需要这些线程间可以按照指定的规则共同完成一件任务，所以这些线程之间就需要互相协调，这个过程被称为线程的通信

#### **共享内存**

+ volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通

+ 所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存 所有volatile修饰的变量在使用之前必须重新读取主内存的值 volatile保证可见性原理图

![img](https://img-blog.csdnimg.cn/img_convert/49c8e5f7b4c0102c3a6cffda3f278716.png)

- 在java中，所有堆内存中的所有的数据（实例域、静态域和数组元素）存放在主内存中可以在线程之间共享，一些局部变量、方法中定义的参数存放在本地内存中不会在线程间共享。线程之间的共享变量存储在主内存中，本地内存存储了共享变量的副本。如果线程A要和线程B通信，则需要经过以下步骤

  - ①线程A把本地内存A更新过的共享变量刷新到主内存中
  - ②线程B到内存中去读取线程A之前已更新过的共享变量

```java
/**
 * @Author: Simon Lang
 * @Date: 2020/5/5 15:13
 */
public class TestVolatile {
    private static volatile boolean flag=true;
    public static void main(String[] args){
        new Thread(new Runnable() {
            public void run() {
                while (true){
                    if(flag){
                        System.out.println("线程A");
                        flag=false;
                    }
                }
            }
        }).start();
​
​
        new Thread(new Runnable() {
            public void run() {
                while (true){
                    if(!flag){
                        System.out.println("线程B");
                        flag=true;
                    }
                }
            }
        }).start();
    }
}
```

#### 消息传递

##### **等待/通知机制**

+ Java提供了Object类的wait()、notify()和notifyAll()方法来实现线程之间的等待和通知。线程可以调用wait()方法进入等待状态，直到其他线程调用notify()或notifyAll()方法唤醒它。这种机制常用于生产者-消费者模型等场景

```java
public class TestSync {
    public static void main(String[] args) {
        // 定义一个锁对象
        Object lock = new Object();
        List<String>  list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            synchronized (lock) {
                for (int i = 1; i <= 10; i++) {
                    list.add("abc");
                    System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (list.size() == 5)
                        lock.notify();// 唤醒B线程
                }
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            while (true) {
                synchronized (lock) {
                    if (list.size() != 5) {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println("线程B收到通知，开始执行自己的业务...");
                }
            }
        });
        //　需要先启动线程B
        threadB.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 再启动线程A
        threadA.start();
    }
}
```

**wait() notify() notifyAll()**

- wait() notify() notifyAll() 都是 Object类的方法，使用这三个方法的前提是先获得该对象的锁
- 调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列
- 调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回
- notify 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 
- notifyAll 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked

>  等待队列（等待池） 同步队列（锁池）
>
> 同步队列（锁池）：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked
>
> 等待队列（等待池）：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）

##### 阻塞队列

+ Java提供了线程安全的阻塞队列（如ArrayBlockingQueue、LinkedBlockingQueue等），线程可以通过向队列中放入元素或者从队列中获取元素来进行通信。当队列为空时，获取操作会阻塞线程，直到队列中有可用元素；当队列已满时，插入操作会阻塞线程，直到队列有空闲位置

```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);

// 在一个线程中放入元素
queue.put("Hello");

// 在另一个线程中获取元素
String element = queue.take();
```

##### 使用 ReentrantLock 结合 Condition

+ Java中的Condition接口提供了更加灵活的线程通信方式。可以通过Lock对象的newCondition()方法获取一个Condition实例，然后线程可以调用await()方法进入等待状态，直到其他线程调用signal()或signalAll()方法来唤醒它们

```java
public class TestSync {
    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        Condition condition = lock.newCondition();

        List<String> list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            lock.lock();
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (list.size() == 5)
                    condition.signal();

            }
            lock.unlock();
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            lock.lock();
            if (list.size() != 5) {
                try {
                    condition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("线程B收到通知，开始执行自己的业务...");
            lock.unlock();
        });
        threadB.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        threadA.start();
    }
}
```

##### 使用JUC工具类 CountDownLatch

+ jdk1.5之后在*java.util.concurrent*包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，***CountDownLatch***基于AQS框架，相当于也是维护了一个线程间共享变量state

```java
public class TestSync {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        List<String>  list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (list.size() == 5)
                    countDownLatch.countDown();
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            while (true) {
                if (list.size() != 5) {
                    try {
                        countDownLatch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("线程B收到通知，开始执行自己的业务...");
                break;
            }
        });
        //　需要先启动线程B
        threadB.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 再启动线程A
        threadA.start();
    }
}
```

##### 基本LockSupport实现线程间的阻塞和唤醒

+ ***LockSupport*** 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程先进行还是唤醒线程先运行，但是得知道线程的名字

```java
public class TestSync {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        // 实现线程B
        final Thread threadB = new Thread(() -> {
            if (list.size() != 5) {
                LockSupport.park();
            }
            System.out.println("线程B收到通知，开始执行自己的业务...");
        });
        // 实现线程A
        Thread threadA = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (list.size() == 5)
                    LockSupport.unpark(threadB);
            }
        });
        threadA.start();
        threadB.start();
    }
}
```

#### **管道输入/输出流**

- 管道流是是一种使用比较少的线程间通信方式，管道输入/输出流和普通文件输入/输出流或者网络输出/输出流不同之处在于，它主要用于线程之间的数据传输，传输的媒介为管道。

- 管道输入/输出流主要包括4种具体的实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，后两种面向字符。

- java的管道的输入和输出实际上使用的是一个循环缓冲数组来实现的，默认为1024，输入流从这个数组中读取数据，输出流从这个数组中写入数据，当这个缓冲数组已满的时候，输出流所在的线程就会被阻塞，当向这个缓冲数组为空时，输入流所在的线程就会被阻塞

![img](https://img-blog.csdnimg.cn/img_convert/0e65d6e4b56d97e2b6fd2fa8633e3dce.png)



```java
buffer：缓冲数组，默认为1024
out：从缓冲数组中读数据
in：从缓冲数组中写数据
```

```java
public class TestPip {
    public static void main(String[] args) throws IOException {
        PipedWriter writer  = new PipedWriter();
        PipedReader reader = new PipedReader();
        //使用connect方法将输入流和输出流连接起来
        writer.connect(reader);
        Thread printThread = new Thread(new Print(reader) , "PrintThread");
        //启动线程printThread
        printThread.start();
        int receive = 0;
        try{
            //读取输入的内容
            while((receive = System.in.read()) != -1){
                writer.write(receive);
            }
        }finally {
            writer.close();
        }
    }
​
    private static class Print implements Runnable {
        private PipedReader reader;
​
        public Print(PipedReader reader) {
            this.reader = reader;
        }
        @Override
        public void run() {
            int receive = 0;
            try{
                while ((receive = reader.read()) != -1){
                    //字符转换
                    System.out.print((char) receive);
                }
            }catch (IOException e) {
                System.out.print(e);
            }
        }
    }
}
```

### Java 如何创建一个线程？

#### 继承Thread类创建线程类 （extends）

- 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体(线程体)

- 创建Thread子类的实例，即创建了线程对象

- 调用线程对象的start()方法来启动该线程
  ```java
    
  public class FirstThreadTest extends Thread{  
      int i = 0;  
      //重写run方法，run方法的方法体就是现场执行体  
      public void run()  
      {  
          for(;i<100;i++){  
          log.info(getName()+"  "+i);  
          }  
      }  
   
      public static void main(String[] args)  
      {  
          for(int i = 0;i< 100;i++)  
          {  
              log.info(Thread.currentThread().getName()+"  : "+i);  
              if(i==20)  
              {  
                  new FirstThreadTest().start();  
                  new FirstThreadTest().start();  
              }  
          }  
      }  
  } 
  ```

#### 通过Runnable接口创建线程类

- 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体
- 创建 Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象

- 调用线程对象的start()方法来启动该线程

```java
public class CreateThreadTest {
    public static void main(String[] args) {
        RunnableTest runnableTest = new RunnableTest();
        new Thread(runnableTest, "线程1").start();
        new Thread(runnableTest, "线程2").start();
    }
}

class RunnableTest implements Runnable{
    private int i = 0;

    @Override
    public void run() {
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()  + " is running: " + i);
        }
    }
}
```

#### 通过Callable和Future创建线程

- 创建Callable接口的实现类，并实现call()方法，该***call()方法将作为线程执行体，并且有返回值***

- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值（FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了Future和Runnable接口）

- 使用FutureTask对象作为Thread对象的target创建并启动新线程

- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值
> Java5提供了Future接口来接收Callable接口中call()方法的返回值
>
> Callable接口是 Java5 新增的接口，不是Runnable接口的子接口，所以Callable对象不能直接作为Thread对象的target
>
> 针对这个问题，引入了RunnableFuture接口，RunnableFuture接口是Runnable接口和Future接口的子接口，可以作为Thread对象的target 。同时，Java5提供了一个RunnableFuture接口的实现类：FutureTask ，FutureTask可以作为 Thread对象的target

![img](https://upload-images.jianshu.io/upload_images/3072290-877afd6489b5f7a7.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp)

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CreateThreadTest {
    public static void main(String[] args) {
        CallableTest callableTest = new CallableTest();
        FutureTask<Integer> futureTask = new FutureTask<>(callableTest);
        new Thread(futureTask).start();
        try {
            System.out.println("子线程的返回值: " + futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class CallableTest implements Callable{

    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i < 101; i++) {
            sum += i;
        }
        System.out.println(Thread.currentThread().getName() + " is running: " + sum);
        return sum;
    }
}
```

#### 创建线程的三种方式的对比

**采用实现Runnable、Callable接口的方式创建多线程**

**优势**

- 可以避免java中单继承的限制

- 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想

- 线程池只能放入Runable或Callable接口实现类，不能直接放入继承Thread的类


**劣势**

+  编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法

**使用继承Thread类的方式创建多线程**

 **优势**

+ 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程

**劣势**

+ 线程类已经继承了Thread类，所以不能再继承其他父类

**Runnable和Callable的区别**

-  call()方法比run()方法功能要强大：call()方法可以有**返回值**，可以**声明抛出异常**

-  运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果future.get()

#### Java同一个线程对象能否多次调用start方法

**最后结论：无论是直接二次调用还是通过反射二次调用，同一个线程对象都无法多次调用start方法，仅可调用一次**

**start方法源码**

```java
/**线程成员变量，默认为0，volatile修饰可以保证线程间可见性*/
private volatile int threadStatus = 0;
/* 当前线程所属的线程组 */
private ThreadGroup group;
/**
 * 同步方法，同一时间，只能有一个线程可以调用此方法
 */
public synchronized void start() {
    //threadStatus
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    //线程组
    group.add(this);
    boolean started = false;
    try {
        //本地方法，该方法会实际调用run方法
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                //创建失败，则从线程组中删除该线程
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* start0抛出的异常不用处理，将会在堆栈中传递 */
        }
    }
}
```

- 通过断点跟踪，可以看到当线程对象第一次调用start方法时会进入同步方法，会判断threadStatus是否为0，如果为0，则进行往下走，否则抛出非法状态异常；
- 将当前线程对象加入线程组；
- 调用本地方法start0执行真正的创建线程工作，并调用run方法，可以看到在start0执行完后，threadStatus的值发生了改变，不再为0；
- finally块用于捕捉start0方法调用发生的异常

### Java中的多线程

- Java程序的进程里有几个线程：主线程，垃圾回收线程(后台线程)等
- 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程

- Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU，Thread类是java.lang包下的一个常用类,每一个Thread类的对象，就代表一个处于某种状态的线程

# 同步机制实现

## Java 中常见的锁

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202307131856108.png)

### 自旋和非自旋锁

![img](https://img-blog.csdnimg.cn/20200913091312996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbnRfd2VuMDc2Ng==,size_16,color_FFFFFF,t_70)

**自旋锁的好处**

- 阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大
- 在很多场景下，可能我们的同步代码块的内容并不多，所以需要的执行时间也很短，如果我们仅仅为了这点时间就去切换线程状态，那么其实不如让线程不切换状态，而是让它自旋地尝试获取锁，等待其他线程释放锁，有时我只需要稍等一下，就可以避免上下文切换等开销，提高了效率

**自旋的缺点**

+ 它最大的缺点就在于虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高

**适用场景**

- 自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率
- 可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源

### **无锁 → 偏向锁 → 轻量级锁 → 重量级锁**

#### **锁升级过程**

![20200603161323889](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202307131959744.png)

> JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率

#### 偏向锁

- 如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁
- 偏向锁的执行流程如下
  - 线程首先检查该对象头的线程ID是否为当前线程；
  - 如果对象头的线程ID和当前线程ID一致，则直接执行代码；
  - 如果不是当前线程ID则使用CAS方式替换对象头中的线程ID，如果使用CAS替换不成功则说明有线程正在执行，存在锁的竞争，这时需要撤销偏向锁，升级为轻量级锁
  - 如果CAS替换成功，则把对象头的线程ID改为自己的线程ID，然后执行代码
  - 执行代码完成之后释放锁，把对象头的线程ID修改为空


> 锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争

#### 轻量级锁

> 自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗

- 在轻量级锁状态下继续锁竞争，如果成功就成功获取轻量级锁。否则进入锁膨胀阶段，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做**忙等**（busy-waiting）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁
- **轻量级锁不会自旋，另一个线程一旦CAS竞争轻量级锁失败，直接进入锁的膨胀。锁膨胀会有自旋操作，但最终在java层面看到的锁状态都会是重量级锁。所以，轻量级锁在加锁过程中是没有自旋的。自旋发生在轻量级锁膨胀为重量级锁的过程中。相反，重量级锁在加锁的过程中，为了避免直接park线程，会有自适应自旋操作，来挽救线程被park**

> ### 轻量级锁是否会自旋
>
> + 轻量级锁流程不会自旋，自旋发生在产生竞争后，获取失败的线程将锁膨胀为重量级锁。失败的线程不会立刻阻塞，而是先尝试适应性自旋，等待所有者释放锁，当到达临界值后再阻塞
>
>  **synchronizer.cpp**
>
> ![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202307131946710.webp)
>
> - 所以 CAS 失败了之后，**并没有什么自旋操作**，如果 CAS 成功就直接 return 了，如果失败会执行下面的锁膨胀方法，从源码来看**轻量级锁 CAS 失败并不会自旋而是直接膨胀成重量级锁**
> - 不过为了优化性能，自旋操作在 Synchronized 中确实却有。那是在已经升级成**重量级锁**之后，线程如果没有争抢到锁，会进行一段自旋等待锁的释放，毕竟阻塞线程入队再唤醒开销还是有点大的
>
> ![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202307131948907.webp)
>
> + 我们再来看看 `TrySpin` 的操作，这里面有**自适应自旋**，其实从实际函数名就 `TrySpin_VaryDuration` 就可以反映出自旋是变化的
>
> ![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202307131949309.webp)

#### 重量级锁

+ 当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程

## CAS

### what

+ CAS 全称为 `Compare And Swap` 翻译过来就是`比较并且交换`
+ cas 的操作则是乐观锁
+ CAS是一种系统原语

> 原语属于操作系统用语，原语由若干指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被终端，也就是说CAS是一条CPU的原子指令

### CAS 机制

在看到 Compare 和 Swap 后，我们就应该知道，CAS 里面至少包含了两个动作，分别是比较和交换，在现在的 CPU 中，为这两个动作专门提供了一个指令，就是`CAH` 指令，由 CPU 来保证这两个操作一定是原子的，也就是说比较和交换这两个操作只能是`要么全部完成，要么全部没有完成`

CAS 机制中使用了三个操作数，内存地址，旧的预期值，要修改的值；

**栗子**

前提：线程 A，B，主内存中的变量 count = 0；

- 线程A： 要修改 count 值，所以 copy 一份到自己的内存中，然后执行了 + 1 的操作，此时线程A中 count 预期值是 0，要修改的值为 1
- 线程B ：也修改 count 值，也执行了 + 1 的操作，此时线程 B 中 count 的预期值是 0，要修改的值为 1，
- 线程B ：开始提交到主内存了，提交的时候判断预期值 和 主内存的 count 是一样的，所以就会提交成功，**这时主内存 count =1**
- 线程A ：也开始提交了，但是在判断的时候发现预期值是 0，但主内存是1，不相等，所以，提交失败，然后就会放弃本次提交。
- 线程A ：提交失败之后，就与重新执行步骤 1 的操作

### 问题

#### **ABA**

- 还是上面的栗子，在线程 A 执行  + 1，操作的时候，线程 B 已经将 + 1的结果提交的主内存了，但是这个时候他又执行了 - 1的操作提交到主内存，并且这个过程快于线程 A
- 这个时候线程 A 进行判断和交换，发现修改的值和主内存的值相同，然后将计算的结果提交
- 在线程 A 执行的过程中，线程 B 修改了值，并且将值又修改了回去，虽然说结果并没有变化，但是值已经被操作过了，这就是典型的 ABA 问题

**解决**

只需要增加一个版本戳即可，在更新值的时候判断一下版本戳即可；在 Java 中也有使用版本戳的实现，就是 `AtomicMarkableReference` 和 `AtomicStampedReference`

- `AtomicMarkReference` ：只关心这个变量有没有被动过
- `AtomicStampedReferrence` ：不但关心这个变量有么有动过，并且关心这个变量被动了几次

#### 开销问题

+ 在 CAS 期间，线程是不会休息的，线程如果长时间无法提交，内部就一直在进行自旋，这样就会产生比较大的内存开销

#### CAS 只能够保证一个共享变量的原子操作

- CAS 只能保证对一个内存地址进行原子操作，所以说使用范围会有一定限制
- 例如：如果在执行 a+1 的下面加上，b+1，c +1，这种情况就会出现问题，这种时候反而使用 Syn 比较方便

- 其实 Java 中也提供了可以修改多个变量的原子操作
- `AtomicReference`：将需要修改的包装成一个对象，然后使用 `AtomicReference` 的 compareAndSet 方法进行替换即可

```java
fun main() {
    val user = User("张三", 31)
    val atomicReference = AtomicReference<User>(user)
    println("${atomicReference.get().name} --- ${atomicReference.get().age}")

    atomicReference.compareAndSet(user, User("李四", 20))
    println("${atomicReference.get().name} --- ${atomicReference.get().age}")
}

class User(val name: String, val age: Int)
```

### 实例

在 java 的 atomic 包下，一系列以 Atomic 开头的包装类，如 `AtomicBoolean` `AtomicInteger` 等，分别用于 int，bool，long 等类型的原子操作，其原理都是用的 cas

## ReentrantLock

### what

+ ReentrantLock是Java在JDK1.5引入的显式锁

### 非公平锁实现原理

> AQS即AbstractQueuedSynchronizer的缩写，这个是个内部实现了两个队列的抽象类，分别是同步队列和条件队列。其中同步队列是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作
>
> 在同步队列中，还存在两种模式，分别是独占模式和共享模式，这两种模式的区别就在于AQS在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应独占锁和共享锁
>
> AQS是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承AQS然后重写获取锁的方式和释放锁的方式还有管理state，而ReentrantLock就是通过重写了AQS的tryAcquire和tryRelease方法实现的lock和unlock

**ReentrantLock结构**

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202307131253132.png)

**非公平锁的实现原理**

+ 当我们使用无参构造方法构造的时候即`ReentrantLock lock = new ReentrantLock()`，创建的就是非公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

//或者传入false参数 创建的也是非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

#### lock方法获取锁

1. `lock`方法调用`CAS`方法设置`state`的值，如果`state`等于期望值`0`(代表锁没有被占用)，那么就将`state`更新为`1`(代表该线程获取锁成功)，然后执行`setExclusiveOwnerThread`方法直接将该线程设置成锁的所有者。如果`CAS`设置`state`的值失败，即`state`不等于`0`，代表锁正在被占领着，则执行`acquire(1)`，即下面的步骤。
2. `nonfairTryAcquire`方法首先调用`getState`方法获取`state`的值，如果`state`的值为`0`(之前占领锁的线程刚好释放了锁)，那么用`CAS`这是`state`的值，设置成功则将该线程设置成锁的所有者，并且返回`true`。如果`state`的值不为`0`，那就**调用`getExclusiveOwnerThread`方法查看占用锁的线程是不是自己**，如果是的话那就直接将`state + 1`，然后返回`true`。如果`state`不为`0`且锁的所有者又不是自己，那就返回`false`，**然后线程会进入到同步队列中**

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aab7befb2e5de~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

```java
final void lock() {
    //CAS操作设置state的值
    if (compareAndSetState(0, 1))
        //设置成功 直接将锁的所有者设置为当前线程 流程结束
        setExclusiveOwnerThread(Thread.currentThread());
    else
        //设置失败 则进行后续的加入同步队列准备
        acquire(1);
}

public final void acquire(int arg) {
    //调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//子类重写的tryAcquire方法
protected final boolean tryAcquire(int acquires) {
    //调用nonfairTryAcquire方法
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    //如果状态state=0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0
    if (c == 0) {
        //使用CAS操作设置state的值
        if (compareAndSetState(0, acquires)) {
            //操作成功 则将锁的所有者设置成当前线程 且返回true，也就是当前线程不会进入同步
            //队列。
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己
    else if (current == getExclusiveOwnerThread()) {
        //如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁 因为锁就在自己
        //身上了。
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    //如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。
    return false;
}
```

#### tryRelease锁的释放

1. 判断当前线程是不是锁的所有者，如果是则进行步骤`2`，如果不是则抛出异常。
2. 判断此次释放锁后`state`的值是否为0，如果是则代表**锁有没有重入**，然后将锁的所有者设置成`null`且返回`true`，然后执行步骤`3`，如果不是则**代表锁发生了重入**执行步骤`4`。
3. 现在锁已经释放完，即`state=0`，唤醒同步队列中的后继节点进行锁的获取。
4. 锁还没有释放完，即`state!=0`，不唤醒同步队列

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aad4a8e578933~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

```java
public void unlock() {
    sync.release(1);
}

public final boolean release(int arg) {
    //子类重写的tryRelease方法，需要等锁的state=0，即tryRelease返回true的时候，才会去唤醒其
    //它线程进行尝试获取锁。
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
    
protected final boolean tryRelease(int releases) {
    //状态的state减去releases
    int c = getState() - releases;
    //判断锁的所有者是不是该线程
    if (Thread.currentThread() != getExclusiveOwnerThread())
        //如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，
        throw new IllegalMonitorStateException();
    boolean free = false;
    //如果该线程释放锁之后 状态state=0，即锁没有重入，那么直接将将锁的所有者设置成null
    //并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，
    //那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

### 公平锁的实现原理

#### lock方法获取锁

1. 获取状态的`state`的值，如果`state=0`即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤`2`。如果`state!=0`则代表锁正在被其它线程占用，执行步骤`3`。
2. **判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。**
3. **判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中**

通过步骤`2`**实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性**

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aaf5a27ee58d5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

```java
final void lock() {
    acquire(1);
}

public final void acquire(int arg) {
    //同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，
    //保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    //判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。
    if (c == 0) {
        //调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有
        //线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行
        //这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    //如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。
    return false;
}
```

#### tryRelease锁的释放

公平锁的释放和非公平锁的释放一样，这里就不重复。
 公平锁和非公平锁的公平性是在**获取锁**的时候体现出来的，释放的时候都是一样释放的

### lockInterruptibly可中断方式获取锁

如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是**可中断锁**，**也就是在执行时可以接收 interrupt 的通知，从而中断锁执行**

`ReentrantLock`相对于`Synchronized`拥有一些更方便的特性，比如可以中断的方式去获取锁

#### 为什么需要可中断锁？

不可中断锁的问题是，当出现“异常”时，只能一直阻塞等待，别无其他办法，比如下面这个程序。下面的这个程序中有两个线程，其中线程 1 先获取到锁资源执行相应代码，而线程 2 在 0.5s 之后开始尝试获取锁资源，但线程 1 执行时忘记释放锁了，这就造成线程 2 一直阻塞等待的情况，实现代码如下

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class InterruptiblyExample {
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();

        // 创建线程 1
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                System.out.println("线程 1：获取到锁.");
                // 线程 1 未释放锁
            }
        });
        t1.start();

        // 创建线程 2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 先休眠 0.5s，让线程 1 先执行
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 获取锁
                System.out.println("线程 2:等待获取锁.");
                lock.lock();
                try {
                    System.out.println("线程 2：获取锁成功.");
                } finally {
                    lock.unlock();
                }
            }
        });
        t2.start();
    }
}
```

以上代码执行的结果如下

![img](https://pic3.zhimg.com/80/v2-39a2770a96492f95c835917fd7d46e4e_1440w.webp)

#### 使用中断锁

- 然而，中断锁的出现，就可以打破这一僵局，它可以在等待一定时间之后，主动的中断线程 2，以解决线程阻塞等待的问题
- 中断锁的核心实现代码是 lock.lockInterruptibly() 方法，它和 lock.lock() 方法作用类似，只不过使用 lockInterruptibly 方法可以优先接收中断的请求，中断锁的具体实现如下

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class InterruptiblyExample {
    public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

        // 创建线程 1
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    // 加锁操作
                    lock.lock();
                    System.out.println("线程 1:获取到锁.");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 线程 1 未释放锁
            }
        });
        t1.start();

        // 创建线程 2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 先休眠 0.5s，让线程 1 先执行
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 获取锁
                try {
                    System.out.println("线程 2:尝试获取锁.");
                    lock.lockInterruptibly(); // 可中断锁
                    System.out.println("线程 2:获取锁成功.");
                } catch (InterruptedException e) {
                    System.out.println("线程 2:执行已被中断.");
                }
            }
        });
        t2.start();

        // 等待 2s 后,终止线程 2
        Thread.sleep(2000);
        if (t2.isAlive()) { // 线程 2 还在执行
            System.out.println("执行线程的中断.");
            t2.interrupt();
        } else {
            System.out.println("线程 2:执行完成.");
        }
    }
}
```

以上代码执行结果如下

![img](https://pic4.zhimg.com/80/v2-5889cb4741cb91b5a328c8cd8df60c4f_1440w.webp)

从上述结果可以看出，当我们使用了 lockInterruptibly 方法就可以在一段时间之后，判断它是否还在阻塞等待，如果结果为真，就可以直接将他中断，如上图效果所示

### tryLock超时等待方式获取锁

`ReentrantLock`除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回`false`，而不是一直"死循环"获取

- 判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用`doAcquireNanos`方法使用超时等待的方式获取锁
- 将当前节点封装成独占模式的节点加入到同步队列的队尾中
- 进入到"死循环"中，**但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回`false`，结束循环**。这里调用的是`LockSupport.parkNanos`方法，在超时时间内没有被中断，那么线程会从**超时等待状态转成了就绪状态**，然后被`CPU`调度继续执行循环，**而这时候线程已经达到超时等到的时间，返回false**

> `LockSuport`的方法能响应`Thread.interrupt`，但是不会抛出异常

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/24/169ade79439826ef~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

### Lock接口的线程获取锁的三种方式

- lock()，如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁；

- tryLock()，如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；

- tryLock(long timeout，TimeUnit unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false

### ReentrantLock的等待/通知机制

我们知道关键字`Synchronized` + `Object`的`wait`和`notify`、`notifyAll`方法能实现**等待/通知**机制，那么`ReentrantLock`是否也能实现这样的等待/通知机制，答案是：可以。
 `ReentrantLock`通过`Condition`对象，也就是**条件队列**实现了和`wait`、`notify`、`notifyAll`相同的语义。 线程执行`condition.await()`方法，将节点1从同步队列转移到条件队列中

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/25/169b3432b128105d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

线程执行`condition.signal()`方法，将节点1从条件队列中转移到同步队列

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/25/169b3411b74cfff1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

因为只有在同步队列中的线程才能去获取锁，所以通过`Condition`对象的`wait`和`signal`方法能实现等待/通知机制

```java
ReentrantLock lock = new ReentrantLock();
Condition condition = lock.newCondition();
public void await() {
    lock.lock();
    try {
        System.out.println("线程获取锁----" + Thread.currentThread().getName());
        condition.await(); //调用await()方法 会释放锁，和Object.wait()效果一样。
        System.out.println("线程被唤醒----" + Thread.currentThread().getName());
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
        System.out.println("线程释放锁----" + Thread.currentThread().getName());
    }
}

public void signal() {
    try {
        Thread.sleep(1000);  //休眠1秒钟 等等一个线程先执行
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    lock.lock();
    try {
        System.out.println("另外一个线程获取到锁----" + Thread.currentThread().getName());
        condition.signal();
        System.out.println("唤醒线程----" + Thread.currentThread().getName());
    } finally {
        lock.unlock();
        System.out.println("另外一个线程释放锁----" + Thread.currentThread().getName());
    }
}

public static void main(String[] args) {
    Test t = new Test();
    Thread t1 = new Thread(new Runnable() {
        @Override
        public void run() {
            t.await();
        }
    });

    Thread t2 = new Thread(new Runnable() {
        @Override
        public void run() {
            t.signal();
        }
    });

    t1.start();
    t2.start();
}
```

运行输出

```java
线程获取锁----Thread-0
另外一个线程获取到锁----Thread-1
唤醒线程----Thread-1
另外一个线程释放锁----Thread-1
线程被唤醒----Thread-0
线程释放锁----Thread-0
```

执行的流程大概是这样，线程`t1`先获取到锁，输出了"线程获取锁----Thread-0"，然后线程`t1`调用`await`方法，调用这个方法的结果就是**线程`t1`释放了锁进入等待状态，等待唤醒**，接下来线程`t2`获取到锁，然输出了"另外一个线程获取到锁----Thread-1"，同时线程`t2`调用`signal`方法，调用这个方法的结果就是**唤醒一个在条件队列(Condition)的线程，然后线程`t1`被唤醒，而这个时候线程`t2`并没有释放锁，线程`t1`也就没法获得锁，等线程`t2`继续执行输出"唤醒线程----Thread-1"之后线程`t2`释放锁且输出"另外一个线程释放锁----Thread-1"，这时候线程`t1`获得锁，继续往下执行输出了`线程被唤醒----Thread-0`，然后释放锁输出"线程释放锁----Thread-0"**。

如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个`Condition`对象了，因为`ReentrantLock`支持创建多个`Condition`对象，例如

```java
//为了减少篇幅 仅给出伪代码
ReentrantLock lock = new ReentrantLock();
Condition condition = lock.newCondition();
Condition condition1 = lock.newCondition();

//线程1 调用condition.await() 线程进入到条件队列
condition.await();

//线程2 调用condition1.await() 线程进入到条件队列
condition1.await();

//线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。
condition1.await();
```

## Synchronized

### 使用

#### 修饰实例方法

+ synchronized修饰实例方法只需要在方法上加上synchronized关键字即可，此时，synchronized加锁的对象就是这个方法所在实例的本身

```java
public synchronized void add(){
       i++;
}
```

#### 修饰静态方法

+ synchronized修饰静态方法的使用与实例方法并无差别，在静态方法上加上synchronized关键字即可，此时，synchronized加锁的对象为当前静态方法所在类的Class对象

```java
public static synchronized void add(){
       i++;
}
```

#### 修饰代码块

+ synchronized修饰代码块需要传入一个对象，很明显，此时synchronized加锁对象即为传入的这个对象实例

```java
synchronized（this）{
    //互斥代码
}
```

## Java对象头与Monitor对象

在JVM中，对象在内存中存储的布局可以分为三个区域，分别是对象头、实例数据以及填充数据。

- **实例数据** 存放类的属性数据信息，包括父类的属性信息，这部分内存按4字节对齐。
- **填充数据** 由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。
- **对象头** 在HotSpot虚拟机中，对象头又被分为两部分，分别为：Mark Word(标记字段)、Class Pointer(类型指针)。如果是数组，那么还会有数组长度

![object_header.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c081fb4576641eaa63e4966703845ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

从图中可以清楚的看到，Mark Word中有2bit的数据用来标记锁的状态。无锁状态和偏向锁标记位为01，轻量级锁的状态为00，重量级锁的状态为10

- 当对象为偏向锁时，Mark Word存储了偏向线程的ID；
- 当状态为轻量级锁时，Mark Word存储了指向线程栈中Lock Record的指针；
- 当状态为重量级锁时，Mark Word存储了指向堆中的Monitor对象的指针

### Monitor对象

- Monitor对象被称为管程或者监视器锁。在Java中，每一个对象实例都会关联一个Monitor对象。这个Monitor对象既可以与对象一起创建销毁，也可以在线程试图获取对象锁时自动生成。当这个Monitor对象被线程持有后，它便处于锁定状态
- 在HotSpot虚拟机中，Monitor是由[ObjectMonitor](https://link.juejin.cn?target=https%3A%2F%2Fhg.openjdk.java.net%2Fjdk8u%2Fjdk8u%2Fhotspot%2Ffile%2F782f3b88b5ba%2Fsrc%2Fshare%2Fvm%2Fruntime%2FobjectMonitor.hpp)实现的,它是一个使用C++实现的类，主要数据结构如下

```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; //记录个数
    _waiters      = 0,
    _recursions   = 0;  // 线程重入次数
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; // 调用wait方法后的线程会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ; // 阻塞队列，线程被唤醒后根据决策判读是放入cxq还是EntryList
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 没有抢到锁的线程会被放到这个队列
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

### 对象头

在对象头的Mark Word中主要存储了对象自身的运行时数据，例如哈希码、GC分代年龄、锁状态、线程持有的锁、偏向线程ID以及偏向时间戳等。同时，Mark Word也记录了对象和锁有关的信息。

当对象被synchronized关键字当成同步锁时，和锁相关的一系列操作都与Mark Word有关。由于在JDK1.6版本中对synchronized进行了锁优化，引入了偏向锁和轻量级锁（关于锁优化后边详情讨论）。Mark Word在不同锁状态下存储的内容有所不同。我们以32位JVM中对象头的存储内容如下图所示

## ReentrantLock和Synchronized对比

|                     |                        ReentrantLock                         |                         Synchronized                         |
| :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      底层实现       |                       通过CAS、AQS实现                       | 通过JVM实现，其中synchronized又有多个类型的锁，除了重量级锁是通过monitor对象锁(操作系统mutex互斥原语)实现外，其它类型的通过对象头实现 |
|     是否可重入      |                              是                              |                              是                              |
|       公平锁        |                              是                              |                              否                              |
|      非公平锁       |                              是                              |                              是                              |
|      锁的类型       |                        悲观锁、显式锁                        |                    悲观锁、隐式锁(内置锁)                    |
|    是否支持中断     |                              是                              |                              否                              |
|  是否支持超时等待   |                              是                              |                              否                              |
| 是否自动获取/释放锁 |                              否                              |                              是                              |
|      锁的对象       | ReentrantLock 锁的是线程，根据进入的线程和 int 类型的 state 标识锁的获得 / 争抢 | synchronzied 锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁 / 争抢锁 |

## 死锁

### 产生死锁的四个必要条件

- 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放

- 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)

- 循环等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源


这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立(即必要不充分条件)，而只要上述条件之一不满足，就不会发生死锁

### 死锁避免

**死锁避免的基本思想**：系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁,则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略

### 死锁预防

- 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造

- 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源

- 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请

- 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源

### 死锁避免和死锁预防的区别

+ **死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现；而死锁避免则不那么严格的限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生**

## volatile

`volatile`是一个轻量级的`synchronized`，一般作用与**变量**，在多处理器开发的过程中保证了内存的可见性。相比于`synchronized`关键字，`volatile`关键字的执行成本更低，效率更高

### volatile的特性有哪些？

- 可见性：`volatile`可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值
- 有序性：`volatile`会通过禁止指令重排序进而保证有序性
- 原子性：对于单个的`volatile`修饰的变量的读写是可以保证原子性的，但对于`i++`这种复合操作并不能保证原子性。这句话的意思基本上就是说`volatile`不具备原子性

### Java内存的可见性问题

**Java的内存模型如下图所示**

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4a6ed02692c404e86524246e8b577e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

这里的本地内存并不是真实存在的，只是Java内存模型的一个抽象概念，它包含了控制器、运算器、缓存等。同时Java内存模型规定，线程对共享变量的操作必须在自己的本地内存中进行，不能直接在主内存中操作共享变量。这种内存模型会出现什么问题呢？

- 线程A获取到共享变量X的值，此时本地内存A中没有X的值，所以加载主内存中的X值并缓存到本地内存A中，线程A修改X的值为1，并将X的值刷新到主内存中，这时主内存及本地内存A中的X的值都为1
- 线程B需要获取共享变量X的值，此时本地内存B中没有X的值，加载主内存中的X值并缓存到本地内存B中，此时X的值为1。线程B修改X的值为2，并刷新到主内存中，此时主内存及本地内存B中的X值为2，本地内存A中的X值为1
- 线程A再次获取共享变量X的值，此时本地内存中存在X的值，所以直接从本地内存中A获取到了X为1的值，但此时主内存中X的值为2，到此出现了所谓内存不可见的问题

该问题Java内存模型是通过`synchronized`关键字和`volatile`关键字就可以解决

### 为什么代码会重排序？

+ 计算机在执行程序的过程中，编译器和处理器通常会对指令进行重排序，这样做的目的是为了提高性能。具体可以看下面这个例子

```java
int a = 1;
int b = 2;
int a1 = a;
int b1 = b;
int a2 = a + a;
int b2 = b + b;
......
```

+ 像这段代码，不断地交替读取a和b，会导致寄存器频繁交替存储a和b，使得代码性能下降，可对其进入如下重排序

```java
int a = 1;
int b = 2;
int a1 = a;
int a2 = a + a;
int b1 = b;
int b2 = b + b;
......
```

按照这样地顺序执行代码便可以避免交替读取a和b，这就是重排序地意义。

指令重排序一般分为编译器优化重排、指令并行重拍和内存系统重排三种。

- 编译器优化重排：编译器在不改变单线程程序语义的情况下，可以对语句的执行顺序进行重新排序。
- 指令并行重排：现代处理器多采用指令级并行技术来将多条指令重叠执行。对于不存在**数据依赖**的程序，处理器可以对机器指令的执行顺序进行重新排列。
- 内存系统重排：因为处理器使用缓存和读/写缓冲区，使得加载（load）和存储（store）看上去像是在乱序执行。

注：简单解释下数据依赖性：如果两个操作访问了同一个变量，并且这两个操作有一个是写操作，这两个操作之间就会存在数据依赖性，例如

```java
a = 1;
b = a;
```

如果对这两个操作的执行顺序进行重排序的话，那么结果就会出现问题，其实，这三种指令重排说明了一个问题，就是指令重排在单线程下可以提高代码的性能，但在多线程下可以会出现一些问题

### 重排序会引发什么问题？

前面已经说过了，在单线程程序中，重排序并不会影响程序的运行结果，而在多线程场景下就不一定了。可以看下面这个经典的例子，该示例出自《Java并发编程的艺术》

```java
class ReorderExample{
    int a = 0;
    boolean flag = false;
    public void writer(){
        a = 1;              // 操作1
        flag = true;        // 操作2
    }
    public void reader(){
        if(flag){          // 操作3
            int i = a + a; // 操作4
        }
    }
}
```

假设线程1先执行`writer()`方法，随后线程2执行`reader()`方法，最后程序一定会得到正确的结果吗？

答案是不一定的，如果代码按照下图的执行顺序执行代码则会出现问题

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94b71c7f9a6b4b708bb27af54359651a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

操作1和操作2进行了重排序，线程1先执行`flag=true`，然后线程2执行操作3和操作4，线程2执行操作4时不能正确读取到`a`的值，导致最终程序运行结果出问题。这也说明了在多线程代码中，重排序会破坏多线程程序的语义

### as-if-serial规则和happens-before规则的区别？

区别

- as-if-serial定义：无论编译器和处理器如何进行重排序，单线程程序的执行结果不会改变
- happens-before定义：一个操作happens-before另一个操作，表示第一个的操作结果对第二个操作可见，并且第一个操作的执行顺序也在第二个操作之前。但这并不意味着Java虚拟机必须按照这个顺序来执行程序。如果重排序的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生
- happens-before关系保证了同步的多线程程序的执行结果不被改变，as-if-serial保证了单线程内程序的执行结果不被改变

相同点：happens-before和as-if-serial的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度

### voliatile的实现原理

#### volatile实现内存可见性原理

`volatile`可以保证内存可见性的关键是`volatile`的读/写实现了缓存一致性，缓存一致性的主要内容为：

- 每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。
- 当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。

那缓存一致性是如何实现的呢？可以发现通过`volatile`修饰的变量，生成汇编指令时会比普通的变量多出一个`Lock`指令，这个`Lock`指令就是`volatile`关键字可以保证内存可见性的关键，它主要有两个作用：

- 将当前处理器缓存的数据刷新到主内存。
- 刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效

#### volatile实现有序性原理

为了实现`volatile`的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。

内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。

#### Java虚拟机插入内存屏障的策略

Java内存模型把内存屏障分为4类，如下表所示

| 屏障类型            | 指令示例                 | 说明                                                         |
| ------------------- | ------------------------ | ------------------------------------------------------------ |
| LoadLoad Barriers   | Load1;LoadLoad;Load2     | 保证Load1数据的读取先于Load2及后续所有读取指令的执行         |
| StoreStore Barriers | Store1;StoreStore;Store2 | 保证Store1数据刷新到主内存先于Store2及后续所有存储指令       |
| LoadStore Barriers  | Load1;LoadStore;Store2   | 保证Load1数据的读取先于Store2及后续的所有存储指令刷新到主内存 |
| StoreLoad Barriers  | Store1;StoreLoad;Load2   | 保证Store1数据刷新到主内存先于Load2及后续所有读取指令的执行  |

注：StoreLoad Barriers同时具备其他三个屏障的作用，它会使得该屏障之前的所有内存访问指令完成之后，才会执行该屏障之后的内存访问命令。

Java内存模型对编译器指定的`volatile`重排序规则为：

- 当第一个操作是`volatile`读时，无论第二个操作是什么都不能进行重排序。
- 当第二个操作是`volatile`写时，无论第一个操作是什么都不能进行重排序。
- 当第一个操作是`volatile`写，第二个操作为`volatile`读时，不能进行重排序。

根据`volatile`重排序规则，Java内存模型采取的是保守的屏障插入策略，`volatile`写是在前面和后面分别插入内存屏障，`volatile`读是在后面插入两个内存屏障，具体如下：

- `volatile`读：在每个`volatile`读后面分别插入LoadLoad屏障及LoadStore屏障（根据`volatile`重排序规则第一条），如下图所示

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5132bf0f67074c22bebfdd3c2a2f377d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

LoadLoad屏障的作用：禁止上面的所有普通读操作和上面的`volatile`读操作进行重排序。

​	LoadStore屏障的作用：禁止下面的普通写和上面的`volatile`读进行重排序。

- `volatile`写：在每个`volatile`写前面插入一个StoreStore屏障（为满足`volatile`重排序规则第二条），在每个`volatile`写后面插入一个StoreLoad屏障（为满足`volatile`重排序规则第三条），如下图所示

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61481c0662f848588dcce98cea888329~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

- StoreStore屏障的作用：禁止上面的普通写和下面的`volatile`写重排序

  StoreLoad屏障的作用：防止上面的`volatile`写与下面可能出现的`volatile`读/写重排序。

#### 编译器对内存屏障插入策略的优化

> 因为Java内存模型所采用的屏障插入策略比较保守，所以在实际的执行过程中，只要不改变`volatile`读/写的内存语义，编译器通常会省略一些不必要的内存屏障

```java
public class VolatileBarrierDemo{
    int a;
    volatile int b = 1;
    volatile int c = 2;
    
    public void test(){
        int i = b;  //volatile读
        int j = c;  //volatile读
        a = i + j;  //普通写
        
    }
}
```

+ 指令序列示意图如下

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce5b339089a842339d688b9fb1bd81e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

+ 从上图可以看出，通过指令优化一共省略了两个内存屏障（虚线表示），省略第一个内存屏障LoadStore的原因是最后的普通写不可能越过第二个`volatile`读，省略第二个内存屏障LoadLoad的原因是下面没有涉及到普通读的操作

#### volatile能使一个非原子操作变成一个原子操作吗？

`volatile`只能保证可见性和有序性，但可以保证64位的`long`型和`double`型变量的原子性。

对于32位的虚拟机来说，每次原子读写都是32位的，会将`long`和`double`型变量拆分成两个32位的操作来执行，这样`long`和`double`型变量的读写就不能保证原子性了，而通过`volatile`修饰的long和double型变量则可以保证其原子性。

#### volatile、synchronized的区别？

- `volatile`主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。`synchronized`主要是解决多个线程访问资源的同步性。
- `volatile`作用于变量，`synchronized`作用于代码块或者方法。
- `volatile`仅可以保证数据的可见性，不能保证数据的原子性。`synchronized`可以保证数据的可见性和原子性。
- `volatile`不会造成线程的阻塞，`synchronized`会造成线程的阻塞



