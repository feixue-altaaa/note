# 基础

## why

- 代码重用性 (即：相同功能的代码，不用多次编写)
- 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
- 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)
- 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
- 使程序呈现高内聚，低耦合的特性

# 六大原则

## 开闭原则

**一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展**

- 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要
- 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求

**优点：实践开闭原则的优点在于可以在不改动原有代码的前提下给程序扩展功能。增加了程序的可扩展性，同时也降低了程序的维护成本**

## 里氏替换原则

**所有引用基类对象的地方能够透明地使用其子类的对象**

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类。但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物

例如有两个类，一个类为`BaseClass`，另一个是`SubClass`类，并且`SubClass`类是`BaseClass`类的子类，那么一个方法如果可以接受一个`BaseClass`类型的基类对象`base`的话，如：`method1(base)`，那么它必然可以接受一个`BaseClass`类型的子类对象`sub`，`method1(sub)`能够正常运行。反过来的代换不成立，如一个方法`method2`接受`BaseClass`类型的子类对象`sub`为参数：`method2(sub)`，那么一般而言不可以有`method2(base)`，除非是重载方法

**里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**

**优点：可以检验继承使用的正确性，约束继承在使用上的泛滥**

## 依赖倒置原则

**抽象不应该依赖于具体类，具体类应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程**

- 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法
- 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求

**优点：通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护**

## 单一职责原则

**一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因**

- 单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中
- 单一职责原则是实现**高内聚、低耦合**的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验

**优点：如果类与方法的职责划分得很清晰，不但可以提高代码的可读性，更实际性地更降低了程序出错的风险，因为清晰的代码会让 bug 无处藏身，也有利于 bug 的追踪，也就是降低了程序的维护成本**

## 迪米特法则（最少知道原则）

**一个软件实体应当尽可能少地与其他实体发生相互作用**

- 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系
- 在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。在类的设计上，只要有可能，一个类型应当设计成不变类。在对其他类的引用上，一个对象对其他对象的引用应当降到最低

**优点：实践迪米特法则可以良好地降低类与类之间的耦合，减少类与类之间的关联程度，让类与类之间的协作更加直接**

## 接口分离原则

**使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口**

- 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干
- 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护。接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便

**优点：避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想**

# 创建型模式

## 单例模式（Singleton Pattern）

单例模式是最常用的设计模式之一。它可以确保在整个应用程序中，某个类只有一个实例存在，并提供一种访问这个实例的全局访问点。单例模式在需要限制某些类的实例数量时非常有用。 它通常用于需要全局访问的资源，如配置文件、日志记录器、数据库连接等

### 应用场景

- **日志记录器** 在一个应用程序中，通常会有多个模块或类需要记录日志。为了避免创建多个日志记录器实例，使用单例模式可以确保只有一个日志记录器实例，从而避免重复记录日志并提高应用程序的性能
- **数据库连接** 在一个应用程序中，如果需要频繁地与数据库交互，使用单例模式可以确保只有一个数据库连接实例，从而减少数据库连接的数量，提高应用程序的性能
- **系统配置** 在一个应用程序中，通常会有一些全局的配置参数，如数据库连接字符串、服务器地址、缓存大小等。使用单例模式可以确保只有一个配置实例，从而方便管理和修改配置参数

### 实现方式

#### 懒汉式

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {
        // 私有构造函数，防止外部实例化
    }
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

+ 线程不安全，可以通过双重检查锁+**volatile**实现懒汉式线程安全

#### 双重检查锁+**volatile**

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

+ 可以在保证线程安全的同时实现延迟加载

#### 静态内部类方式

+ `SingletonHolder`是一个静态内部类，它包含一个静态的`INSTANCE`成员变量，用于存储单例对象。在第一次调用`getInstance`方法时，静态内部类会被加载，从而创建单例对象。这种方式既兼顾了线程安全又兼顾了延迟加载的需求

```java
public class Singleton {
    private Singleton() {
        // 私有构造函数，防止外部实例化
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
}
```

#### 饿汉式

+ 饿汉式在类加载时就创建了单例对象，所以不存在线程安全问题。不过，这种方式可能会导致不必要的资源浪费，因为单例对象的创建可能在应用程序启动时就完成了，而有些应用场景中可能并不需要使用单例对象

```java
public class Singleton {
    // 在类加载时就创建单例对象
    private static Singleton instance = new Singleton();
    
    // 将构造函数设为私有，禁止外部创建实例
    private Singleton() {}
    
    // 提供获取单例对象的方法
    public static Singleton getInstance() {
        return instance;
    }
}
```

#### 枚举方式

+ 使用枚举实现单例模式的好处是，可以避免反射和序列化攻击。因为枚举类型的构造函数是私有的，所以无法使用反射来创建实例；而且枚举类型的实例在序列化和反序列化时会自动处理好，所以也无法通过序列化和反序列化来破坏单例

```java
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        // TODO: 实现单例对象的功能
    }
}
```

### 使用小结

- 对线程安全和性能要求较高，可以考虑使用**饿汉式**或**双重检查锁**方式实现单例模式。这两种方式都能保证线程安全，而且在大多数情况下性能也比较好。
- 如果你对线程安全要求不是很高，或者希望在第一次访问时才创建单例对象，可以考虑使用**懒汉式**或者**静态内部类方式**。这两种方式都是延迟加载的，只有在需要时才会创建单例对象。懒汉式不是线程安全的，需要通过加锁等方式来保证线程安全；而静态内部类方式则是天生线程安全的，不需要额外的处理。
- 希望实现简单、代码少，且不需要考虑线程安全和延迟加载的问题，可以考虑使用**枚举方式**。这种方式不仅代码简单，而且天生线程安全、单例对象创建和调用都很方便

## 工厂模式（Factory Pattern）

工厂模式是一种创建型模式，它可以为开发人员提供一种在不直接实例化对象的情况下创建对象的方法。工厂模式通过提供一个通用的接口和一组实现，来隐藏具体实现的细节，从而降低了代码的耦合度和依赖性

### 应用场景

- 对象的创建过程比较复杂，需要进行封装：如果创建一个对象需要进行复杂的初始化过程，或者需要从多个地方获取数据才能创建对象，那么使用工厂模式可以将这些过程封装起来，让客户端代码更加简洁和易于理解
- 需要动态扩展或修改对象的创建过程：如果需要增加或修改某个对象的创建过程，而又不希望对客户端代码产生影响，那么使用工厂模式可以很方便地实现这个需求
- 需要统一管理对象的创建：如果需要统一管理对象的创建过程，或者需要对创建的对象进行某些统一的处理，那么使用工厂模式可以很好地实现这个需求
- 需要根据不同的条件创建不同的对象：如果需要根据不同的条件来创建不同类型的对象，那么使用工厂模式可以很方便地实现这个需求

### 代码实现

+ 通过一个工厂类来封装对象的创建过程，客户端只需要告诉工厂类需要创建哪种类型的对象即可。将对象的创建过程与客户端代码分离开来，使代码更加灵活和易于扩展

```java
// 定义产品接口
public interface Product {
    void operation();
}

// 具体产品类A
public class ConcreteProductA implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA operation.");
    }
}

// 具体产品类B
public class ConcreteProductB implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB operation.");
    }
}

// 工厂类
public class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ConcreteProductA();
        } else if ("B".equals(type)) {
            return new ConcreteProductB();
        } else {
            throw new IllegalArgumentException("Invalid product type.");
        }
    }
}
```

+ 客户端可以通过调用`SimpleFactory.createProduct`方法来创建不同类型的产品对象

```java
Product productA = SimpleFactory.createProduct("A");
productA.operation(); // 输出 "ConcreteProductA operation."

Product productB = SimpleFactory.createProduct("B");
productB.operation(); // 输出 "ConcreteProductB operation."
```

### 使用小结

+ 在`Java`中，工厂模式广泛应用于各种框架和类库中，例如JDBC中的`DataSource`工厂、`Spring`框架中的`Bean`工厂、`MyBatis`框架中的`SqlSessionFactory`等等

## 抽象工厂模式（Abstract Factory Pattern）

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象

**Java 抽象工厂模式可以在许多应用程序和框架中找到，它可以帮助您更好地组织和管理代码，提高代码的可扩展性和灵活性**

在Java中，抽象工厂模式通常包括以下几个角色

- `AbstractFactory`：抽象工厂，声明了创建产品对象的方法
- `ConcreteFactory`：具体工厂，实现了创建产品对象的方法
- `AbstractProduct`：抽象产品，声明了产品对象的共性接口
- `Product`：具体产品，实现了抽象产品中的抽象方法，构成产品族
- `Client`：客户端，通过调用工厂类的方法创建产品对象

> 抽象工厂和工厂模式都是创建对象的设计模式，它们的主要区别什么呢?
>
> - 目的不同：工厂模式用于创建一类产品对象的实例，而抽象工厂模式用于创建一组相关的产品对象实例。
> - 实现方式不同：工厂模式中只有一个工厂类，该类负责创建所有的产品对象；而抽象工厂模式中有多个工厂类，每个工厂类负责创建一组相关的产品对象。
> - 范围不同：工厂模式通常用于创建单个对象，而抽象工厂模式通常用于创建一组相关的对象

### 使用场景

- 当需要创建一组相关的产品对象，这些产品对象之间有共同的约束条件，需要一起使用时，可以使用抽象工厂模式
- 当系统需要独立于产品的创建，组装和表示时，可以使用抽象工厂模式
- 当系统需要支持多个不同的产品族，且不希望依赖于具体产品类时，可以使用抽象工厂模式
- 当系统需要在运行时切换不同的产品族时，可以使用抽象工厂模式
- 当需要遵循“开闭原则”，即系统需要扩展新的产品族时，不需要修改已有代码，可以使用抽象工厂模式

**优点**

- 具体产品在应用层的代码隔离，无需关系创建的细节
-  将一个系列的产品统一到一起创建

**缺点**

- 规定了所有可能被创建的产品集合，**产品族**中扩展新的产品困难；
- 增加了系统的抽象性和理解难度

> **产品族**难扩展，**产品等级**易扩展
>
> 理解产品族和产品等级
>
> - 产品族：一个品牌下面的所有产品；例如小米下面的打印机，扫码枪 称为小米的产品族；
> - 产品等级：多个品牌下面的同种产品；例如惠普和小米下面的打印机 称为一个产品等级；
>
> ![image-20210917095922593](https://img-blog.csdnimg.cn/img_convert/4df07daec8eb89f3fec40aa27956ca14.png#pic_center)

### 实现方式

假设当前电脑上接了3种类型设备，每种类型的还有不同的厂商，打印机（惠普打印机，小米打印机。。。等等），扫码枪（惠普扫码枪，小米扫码枪。。。等等），身份证读卡器（惠普读卡器，小米读卡器。。。等等）

如何设计一个插件系统，需要符合以下要求

  - 每种类型的都要能做到动态切换，比如打印机，可以随意切换不同的厂商。
  - 需要考虑扩展
  - 需要考虑代码复用

#### 创建打印机、扫码枪和读卡器的接口

```java
//读卡器接口
public interface IIdCard {
    void read();
}
//扫码枪接口
public interface ISaoma {
    void saoma();
}
//打印机接口
public interface IPrint{
    void print();
}
```

#### 创建实现上述接口的实现类

```java
//小米读卡器
public class MiCard implements IIdCard{
    @Override
    public void read() {
        System.out.println("Inside MiCard::read() method.");
    }
}
//小米扫码枪
public class MISaoma implements ISaoma{
    @Override
    public void saoma() {
		System.out.println("Inside MISaoma::saoma() method.");
    }
}
//小米打印机
public class MiPrint extends Miaaa {
    @Override
    public void print() {
        System.out.println("Inside MiPrint::print() method.");
    }
}
//惠普读卡器
public class HPCard implements IIdCard{
    @Override
    public void read() {
        System.out.println("Inside HPCard::read() method.");
    }
}
//惠普扫码枪
public class HPSaoma implements ISaoma{
    @Override
    public void saoma() {
        System.out.println("Inside HPSaoma::saoma() method.");
    }
}
//惠普打印机
public class HPPrint implements IPrint{
    @Override
    public void print() {
        System.out.println("Inside HPPrint::print() method.");
    }
}
```

#### 创建工厂模式的核心，根据参数决定获取那个产品族

```java
//抽象工厂模式的核心,根据参数决定获取那个产品族
public abstract class AbStractFactory {
    public abstract IPrint getPrint(String name);
    public abstract IIdCard getCard(String name);
    public abstract ISaoma getSaoma(String name);
}
```

#### 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象

```java
//读卡器工厂
public class CardFactory extends AbStractFactory {

    @Override
    public IPrint getPrint(String name) {
        return null;
    }

    @Override
    public IIdCard getCard(String name) {
        if ("Mi".equalsIgnoreCase(name)){
            return new MiCard();
        }else if ("HP".equalsIgnoreCase(name)){
            return new HPCard();
        }
        return null;
    }

    @Override
    public ISaoma getSaoma(String name) {
        return null;
    }
}
//扫码枪工厂
public class SaomaFactory extends AbStractFactory {

    @Override
    public IPrint getPrint(String name) {
        return null;
    }

    @Override
    public IIdCard getCard(String name) {
        return null;
    }

    @Override
    public ISaoma getSaoma(String name) {
        if ("Mi".equalsIgnoreCase(name)){
            return new MISaoma();
        }else if ("HP".equalsIgnoreCase(name)){
            return new HPSaoma();
        }
        return null;
    }
}
//打印机工厂
public class PrintFactory extends AbStractFactory {

    @Override
    public IPrint getPrint(String name) {
        if ("Mi".equalsIgnoreCase(name)){
            return new MiPrint();
        }else if ("HP".equalsIgnoreCase(name)){
            return new HPPrint();
        }
        return null;
    }

    @Override
    public IIdCard getCard(String name) {
        return null;
    }

    @Override
    public ISaoma getSaoma(String name) {
        return null;
    }
}
```

#### 创建一个工厂创造器/生成器类，通过传递参数来获取工厂

```java
public abstract class FactoryProducer {
    static AbStractFactory getFactory(String s) {
        if ("Card".equalsIgnoreCase(s)){//返回读卡器工厂
            return new CardFactory();
        }else if ("Print".equalsIgnoreCase(s)){//返回打印机工厂
            return new PrintFactory();
        }else if ("Saoma".equalsIgnoreCase(s)){//返回扫码枪工厂
            return new SaomaFactory();
        }
        return null;
    }
}
```

#### 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象

```java
public class AbstractFactoryPatternDemo {
    public static void main(String[] args) {
        System.out.println("=============读卡器================");
        //获取读卡器工厂
        AbStractFactory cardFactory= FactoryProducer.getFactory("Card");
        //获取小米读卡器的对象
        IIdCard miCard= cardFactory.getCard("Mi");
        //调用小米读卡器的 read 方法
        miCard.read();
        //获取惠普读卡器的对象
        IIdCard HPCard= cardFactory.getCard("HP");
        //调用惠普读卡器的 read 方法
        HPCard.read();

        System.out.println("=============扫码枪================");
        //获取扫码枪工厂
        AbStractFactory saoMaFactory= FactoryProducer.getFactory("SaoMa");
        //获取小米读卡器的对象
        ISaoma miSaoma= saoMaFactory.getSaoma("Mi");
        //调用小米读卡器的 saoma 方法
        miSaoma.saoma();
        //获取惠普读卡器的对象
        ISaoma HPSaoma= saoMaFactory.getSaoma("HP");
        //调用惠普读卡器的 read 方法
        HPSaoma.saoma();

        System.out.println("=============打印机================");
        //获取扫码枪工厂
        AbStractFactory printFactory= FactoryProducer.getFactory("print");
        //获取小米读卡器的对象
        IPrint miPrint= printFactory.getPrint("Mi");
        //调用小米读卡器的 saoma 方法
        miPrint.print();
        //获取惠普读卡器的对象
        IPrint HPPrint= printFactory.getPrint("HP");
        //调用惠普读卡器的 read 方法
        HPPrint.print();
    }
}
```

[抽象工厂模式总结和示例](https://blog.csdn.net/m0_46502538/article/details/120343296)

### 使用小结

Java 抽象工厂模式在很多框架和应用程序中都有广泛的应用。以下是一些具体的应用

- Java 数据库连接框架 JDBC 中，使用抽象工厂模式来创建连接对象，例如 Connection、Statement 等。
- Java 中的 XML 处理器 DOM 和 SAX，也使用抽象工厂模式来创建解析器和生成器对象。
- Java 中的 Java Cryptography Architecture (JCA) 也使用抽象工厂模式，用于创建加密算法和密钥生成器对象

## **建造者模式**（Builder Pattern）

Java建造者模式（Builder Pattern）是一种创建型设计模式，它通过将一个复杂的对象的创建过程分解成多个简单的步骤，并将这些步骤封装到一个Builder对象中，从而可以灵活地创建不同的对象

### 使用场景

- 当需要创建复杂的对象，并且对象的构建过程包含多个步骤时，可以使用建造者模式
- 当需要创建不同配置的对象时，可以使用建造者模式。
- 当需要创建可变的对象时，可以使用建造者模式。

### 代码实现

```java
public class User {
    private String name;
    private String email;
    private int age;
    
    private User(Builder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
    }
    
    public static class Builder {
        private String name;
        private String email;
        private int age;
        
        public Builder setName(String name) {
            this.name = name;
            return this;
        }
        
        public Builder setEmail(String email) {
            this.email = email;
            return this;
        }
        
        public Builder setAge(int age) {
            this.age = age;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}
```

+ 建造者模式创建User对象

### 使用小结

- `StringBuilder` 类就是一个建造者模式的典型应用。它允许使用者逐步构建一个字符串，并最终返回构建好的字符串
- `Guava` 库是一个常用的Java库，其中的 `ImmutableList.Builder` 类也是一个典型的建造者模式应用。它允许使用者逐步构建一个不可变的列表，并最终返回构建好的列表

总之，建造者模式在Java中的应用非常广泛，特别是在构建复杂对象时，它可以使构建过程更加灵活、可扩展和可维护

## **原型模式**（Prototype Pattern）

Java原型模式（Prototype Pattern）是一种创建型设计模式，其目的是通过复制现有对象来创建新的对象

### 使用场景

- 当对象创建的过程比较耗时或者比较复杂，例如需要进行复杂的计算或者涉及到网络请求等操作，可以使用原型模式来避免重复的初始化过程。
- 当需要创建的对象需要和其他对象进行协同工作时，例如需要创建一个包含多个对象的组合对象，可以使用原型模式来复制一个已有的组合对象，然后进行修改来创建新的组合对象。
- 当需要动态地增加或者删除一些对象时，可以使用原型模式来复制一个已有的对象，然后进行修改来创建新的对象。
- 当需要保护对象的复杂状态时，例如当一个对象的创建需要大量的数据初始化时，可以使用原型模式来保护这些数据，避免因为对象的复制而产生意外的副作用。

### 代码实现

```java
// 定义一个原型接口
interface Prototype {
    public Prototype clone();
}

// 具体的原型类
class ConcretePrototype implements Prototype {
    public Prototype clone() {
        return new ConcretePrototype();
    }
}

// 客户端代码
class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype();
        Prototype clone = prototype.clone();
    }
}
```

### 使用小结

- Java中的`Object`类实现了`Cloneable`接口，这就意味着Java中的任何对象都可以实现原型模式。通过实现`Cloneable`接口，并重写`Object`类中的`clone()`方法，可以实现原型模式。例如 `ArrayList、HashMap `等集合类都实现了`Cloneable` 接口，可以通过复制现有对象来创建新的对象。
- Java中的线程池也是使用了原型模式，线程池中的每个线程都是从原型线程中复制而来，而不是每次创建新的线程

# 结构型模式

## 适配器模式（Adapter Pattern）

适配器模式是一种结构型模式，它可以将一个类的接口转换成客户端所期望的另一种接口。适配器模式可以帮助开发人员在不修改现有代码的情况下，将不兼容的类组合在一起。适配器模式包括以下几个组成部分

- 目标接口（`Target Interface`）：客户端期望的接口。
- 适配器（`Adapter`）：充当两个不兼容接口之间的桥梁，使得它们可以互相通信。
- 适配者（`Adaptee`）：需要被适配的对象，它的接口与目标接口不兼容。
- 客户端（`Client`）：使用目标接口的对象。

### 应用场景

- 当需要将一个已有的类或接口与另一个不兼容的类或接口进行协同工作时。
- 当需要对一个已有的类或接口进行修改，以满足客户端的需求时，但是不希望修改该类或接口的源代码。
- 当需要重新使用一个已有的类或接口，但是不能直接使用该类或接口的方法时。

### 代码实现

- 在这个示例中，我们有一个目标接口 `Target` 和一个不兼容的适配者 `Adaptee`，我们需要创建一个适配器 `Adapter` 来让它们能够一起工作
- 适配器实现了目标接口 `Target`，并在构造函数中接受一个适配者对象 `Adaptee`，然后在实现目标接口的 `request` 方法中调用适配者的 `specificRequest` 方法
- 在客户端中，我们创建了一个适配者对象 `adaptee`，并将其传递给适配器的构造函数创建一个适配器对象 `adapter`。最后，我们使用目标接口 `Target` 中定义的方法 `request` 来访问适配器，从而调用适配者的方法

```java
// 目标接口
interface Target {
    void request();
}

// 适配者
class Adaptee {
    void specificRequest() {
        System.out.println("Adaptee specificRequest.");
    }
}

// 适配器
class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.specificRequest();
    }
}

// 客户端
public class AdapterPatternDemo {
    public static void main(String[] args) {
        Adaptee adaptee = new Adaptee();
        Target target = new Adapter(adaptee);
        target.request();
    }
}
```

### 使用小结

适配器模式是一种非常有用的设计模式，在`JDK`中被广泛应用，可以提供一致的接口，比如

- `Java IO` 流是一个常见的适配器模式的例子。它提供了一组标准的接口来访问各种类型的数据源，包括文件、网络连接、内存等等。每个数据源都有自己的接口，但是 `Java IO` 流可以将这些不同的接口转换为标准的接口，从而提供一致的访问方式。
- `Java Servlet API `也是一个常见的适配器模式的例子。它定义了一组接口来处理 `HTTP` 请求和响应，包括 `doGet()、doPost()、doPut() `等等。每个 `Servlet` 都必须实现这些接口，但是用户只需要实现其中的一部分即可。这些 `Servlet` 之间的适配工作由 `Servlet` 容器完成

## 过滤器模式（Filter Pattern）

Java 过滤器模式（Filter Pattern）是一种结构型设计模式，它允许你使用不同的标准来过滤一组对象，从而去除其中不需要的元素

### 使用场景

- 当你需要从一个集合中过滤出一部分元素时。
- 当你需要根据不同的标准来过滤同一个集合时。
- 当你需要在一个集合中根据不同标准来组合过滤器时。

### 代码实现

假设有一个 `Person` 类，包含姓名、年龄、性别等属性，我们可以定义一个过滤器接口 `Filter`，其中包含一个过滤方法 `filter`，用于过滤出符合某种条件的人

```java
public interface Filter {
    List<Person> filter(List<Person> persons);
}
```

+ 定义实现了 `Filter` 接口的具体过滤器

```java
public class MaleFilter implements Filter {
    @Override
    public List<Person> filter(List<Person> persons) {
        return persons.stream()
                .filter(person -> person.getGender().equals("MALE"))
                .collect(Collectors.toList());
    }
}

public class FemaleFilter implements Filter {
    @Override
    public List<Person> filter(List<Person> persons) {
        return persons.stream()
                .filter(person -> person.getGender().equals("FEMALE"))
                .collect(Collectors.toList());
    }
}

public class AgeFilter implements Filter {
    @Override
    public List<Person> filter(List<Person> persons) {
        return persons.stream()
                .filter(person -> person.getAge() > 18)
                .collect(Collectors.toList());
    }
}
```

+ 最后，我们可以定义一个 `FilterChain` 类，用于组合多个过滤器

```java
public class FilterChain implements Filter {
    private List<Filter> filters;

    public FilterChain(List<Filter> filters) {
        this.filters = filters;
    }

    @Override
    public List<Person> filter(List<Person> persons) {
        List<Person> result = persons;
        for (Filter filter : filters) {
            result = filter.filter(result);
        }
        return result;
    }
}
```

+ 这样，我们就可以使用过滤器来过滤出符合不同条件的人

```java
public static void main(String[] args) {
    List<Person> persons = new ArrayList<>();
    persons.add(new Person("Tom", 20, "MALE"));
    persons.add(new Person("Lucy", 19, "FEMALE"));
    persons.add(new Person("John", 17, "MALE"));
    persons.add(new Person("Lily", 21, "FEMALE"));

    Filter maleFilter = new MaleFilter();
    Filter femaleFilter = new FemaleFilter();
    Filter ageFilter = new AgeFilter();

    FilterChain maleAndAgeFilter = new FilterChain(Arrays.asList(maleFilter, ageFilter));
    FilterChain femaleAndAgeFilter = new FilterChain(Arrays.asList(femaleFilter, ageFilter));

    System.out.println("Male and age filter:");
    maleAndAgeFilter.filter(persons).forEach(System.out::println);
    //Person(name=Tom, age=20, gender=MALE)
    //Person(name=Lily, age=21, gender=FEM

    System.out.println("Female and age filter:");
    femaleAndAgeFilter.filter(persons).forEach(System.out::println);
    //Person(name=Lily, age=21, gender=FEMALE)
}
```

### 使用小结

滤器模式的核心是 `Filter` 接口，该接口包含了一个方法 `filter()`，用于对对象进行过滤。根据具体实现，filter() 方法可以接受一个对象作为参数，然后根据特定的标准判断该对象是否应该被过滤掉。过滤器模式在Java中可以应用于许多场景，例如

- Web开发中，对HTTP请求进行过滤，例如身份验证，日志记录等。
- 在Spring框架中，过滤器可以用于过滤请求并对请求进行预处理，例如对请求参数进行验证等。
- Java 中的 `Stream API `提供了丰富的过滤器方法,如 `filter()、distinct()、map() `等

过滤器模式可以用于任何需要对数据进行过滤和处理的场景

## 装饰器模式（Decorator Pattern）

装饰器模式是一种结构型模式，它可以允许开发人员在不修改现有对象的情况下，动态地添加新功能。装饰器模式通过将一个对象包装在另一个对象中来扩展它的行为，从而提高了代码的灵活性和可重用性

### 应用场景

- 当需要在不修改现有对象结构的前提下增加新的功能或特性时，可以使用装饰器模式。这样可以保持原有代码的稳定性和兼容性，同时也可以增加代码的灵活性和可扩展性
- 当需要动态地向对象添加或删除功能时，可以使用装饰器模式。这样可以在运行时动态地添加或删除功能，而不需要修改现有的代码
- 当需要为多个对象添加相同的功能时，可以使用装饰器模式。这样可以将相同的功能封装在装饰器中，以便于复用和管理

### 代码实现

- 该示例代码中，`Shape` 是一个接口，定义了一个 `draw` 方法，表示绘制图形的操作。`Circle` 是一个实现 `Shape` 接口的类，表示一个圆形
- `ShapeDecorator` 是一个装饰器抽象类，实现了 `Shape` 接口，并包含一个 `Shape` 类型的变量 
- `decoratedShape`，表示要装饰的对象。`RedShapeDecorator` 是一个具体的装饰器类，继承了 `ShapeDecorator` 类，并实现了 `draw` 方法，在绘制图形时添加了一个红色的边框
- 在 `main` 方法中，我们创建了原始对象 `Circle`，以及两个装饰器对象 `RedShapeDecorator`，分别装饰了 `Circle` 和 `Rectangle` 对象。通过调用 `draw` 方法，我们可以看到对象被动态地添加了一个红色的边框，而不需要修改原有的代码

```java
// 定义接口
interface Shape {
    void draw();
}

// 实现接口
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Shape: Circle");
    }
}

class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Shape: Rectangle");
    }
}

// 装饰器抽象类
abstract class ShapeDecorator implements Shape {
    protected Shape decoratedShape;

    public ShapeDecorator(Shape decoratedShape){
        this.decoratedShape = decoratedShape;
    }

    public void draw(){
        decoratedShape.draw();
    }
}

// 具体装饰器类
class RedShapeDecorator extends ShapeDecorator {
    public RedShapeDecorator(Shape decoratedShape) {
        super(decoratedShape);
    }

    @Override
    public void draw() {
        decoratedShape.draw();
        setRedBorder(decoratedShape);
    }

    private void setRedBorder(Shape decoratedShape){
        System.out.println("Border Color: Red");
    }
}

// 测试代码
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        // 创建原始对象
        Shape circle = new Circle();

        // 创建装饰器对象
        Shape redCircle = new RedShapeDecorator(new Circle());
        Shape redRectangle = new RedShapeDecorator(new Rectangle());

        // 调用方法
        System.out.println("Circle with normal border");
        circle.draw();

        System.out.println("\nCircle of red border");
        redCircle.draw();

        System.out.println("\nRectangle of red border");
        redRectangle.draw();
    }
}
```

### 使用小结

在实际应用中，装饰器模式经常用于图形界面(`GUI`)开发、输入/输出流处理、缓存机制、日志记录等领域，可以有效地提高程序的可扩展性和可维护性。比如

- 装饰器模式被广泛应用于`Java IO`流中，以提供各种不同的功能，如缓存、压缩、加密等等。例如，可以使用 `BufferedReader` 来缓存读取文件的数据，使用 `GZIPOutputStream` 来压缩数据，使用 `CipherOutputStream` 来加密数据等等。
- Java Swing 组件是一个经典的装饰器模式的例子。它允许在运行时动态地向组件添加功能，如边框、背景、文本等等。例如，可以使用 `BorderFactory` 来向组件添加边框，使用 `Color` 来设置组件的背景颜色，使用 `Font` 来设置组件的字体等等。
- 在 `Spring` 框架中，装饰器模式被广泛应用于实现 `AOP`。`AOP`通过代理模式和装饰器模式实现。`JDK` 动态代理和 `CGLIB` 动态代理两种方式实现代理模式，使用装饰器模式对目标对象进行包装，从而实现通知 (`Advice`) 的织入。例如，可以使用 `@Transactional` 来添加事务处理的功能，使用 `@Cacheable `来添加缓存处理的功能，等等

## 代理模式（Proxy Pattern）

代理模式是一种结构型设计模式，它为其他对象提供一个代理以控制对该对象的访问。代理是一个具有与原始对象相同的接口的对象，客户端不必知道它与原始对象交互的方式。代理可以拦截对原始对象的访问，并在某些情况下将请求传递给原始对象。

  代理模式有两种主要形式:

- 静态代理：在编译时就已经确定了代理类和被代理类之间的关系，通常需要为每个被代理类都编写一个对应的代理类，并实现相同的接口。 静态代理的优点是简单易懂，缺点是不灵活，代码冗余。
- 动态代理：在运行时动态生成代理对象，并根据反射机制调用被代理类的方法。 动态代理可以使用`Java`原生API或者第三方框架来实现，如`JDK Proxy、CGLIB、`等。 动态代理的优点是灵活高效，缺点是复杂难懂。

### 使用场景

代理模式的主要目的是通过代理对象来控制对原始对象的访问，并提供一些额外的功能。比如

- 当我们想要隐藏某个类时，可以为其提供代理类。例如，我们想要访问一个远程对象，但是不想暴露其网络细节，就可以使用代理类来封装网络通信
- 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现。例如，我们想要限制某些用户对某些方法的访问，就可以在代理类中进行权限检查。
- 当我们要扩展某个类的某个功能时，可以使用代理模式。 例如，我们想要在调用某个方法之前或之后添加日志、缓存、事务等功能，就可以在代理类中实现

### 代码实现

#### 静态代理

一个简单的 Java 静态代理例子，它模拟了一个银行账户的操作

```java
// 定义一个账户接口
public interface Account {
    void deposit(double amount);
    void withdraw(double amount);
}

// 实现账户接口的类
public class BankAccount implements Account {
    private double balance;

    public BankAccount(double balance) {
        this.balance = balance;
    }

    public void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited " + amount + ", balance is now " + balance);
    }

    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("Withdrew " + amount + ", balance is now " + balance);
        } else {
            System.out.println("Sorry, insufficient balance");
        }
    }
}

// 定义一个账户代理类
public class AccountProxy implements Account {
    private BankAccount bankAccount;

    public AccountProxy(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
    }

    public void deposit(double amount) {
        bankAccount.deposit(amount);
    }

    public void withdraw(double amount) {
        bankAccount.withdraw(amount);
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        // 创建一个银行账户实例
        BankAccount account = new BankAccount(1000.0);

        // 创建一个账户代理实例
        Account accountProxy = new AccountProxy(account);

        // 使用账户代理进行操作
        accountProxy.deposit(500.0);
        accountProxy.withdraw(200.0);
        accountProxy.withdraw(2000.0);
    }
}
```

- 在上面的例子中，`BankAccount` 是账户接口 `Account` 的实现类，它负责实际的存款和取款操作。而 `AccountProxy` 则是账户代理类，它实现了账户接口，并在其中持有一个 `BankAccount` 实例。在 `AccountProxy` 的 `deposit` 和 `withdraw` 方法中，它会将操作转发给 `BankAc`
- 在 `Main` 方法中，客户端使用代理来执行操作，而无需直接操作实际对象

#### 动态代理

+ 使用 Java 内置的 `java.lang.reflect.Proxy` 类来创建动态代理

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 定义一个账户接口
public interface Account {
    void deposit(double amount);
    void withdraw(double amount);
}

// 实现账户接口的类
public class BankAccount implements Account {
    private double balance;

    public BankAccount(double balance) {
        this.balance = balance;
    }

    public void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited " + amount + ", balance is now " + balance);
    }

    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("Withdrew " + amount + ", balance is now " + balance);
        } else {
            System.out.println("Sorry, insufficient balance");
        }
    }
}

// 定义一个账户代理类
public class AccountProxy implements InvocationHandler {
    private BankAccount bankAccount;

    public AccountProxy(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getName().equals("deposit")) {
            System.out.println("Before deposit");
            method.invoke(bankAccount, args);
            System.out.println("After deposit");
        } else if (method.getName().equals("withdraw")) {
            System.out.println("Before withdraw");
            method.invoke(bankAccount, args);
            System.out.println("After withdraw");
        }
        return null;
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        // 创建一个银行账户实例
        BankAccount account = new BankAccount(1000.0);

        // 创建一个账户代理实例
        AccountProxy accountProxy = new AccountProxy(account);

        // 使用动态代理创建一个代理对象
        Account proxy = (Account) Proxy.newProxyInstance(
                Account.class.getClassLoader(),
                new Class<?>[] { Account.class },
                accountProxy
        );

        // 使用代理对象进行操作
        proxy.deposit(500.0);
        proxy.withdraw(200.0);
        proxy.withdraw(2000.0);
    }
}
```

- `BankAccount` 和 `AccountProxy` 类的定义与静态代理例子相同。不同之处在于，我们创建了一个实现了 `InvocationHandler` 接口的 `AccountProxy` 类，它的 `invoke` 方法用来处理代理对象的方法调用。在 `invoke` 方法中，我们可以根据被调用的方法名称来添加一些额外的功能。在这个例子中，我们为 `deposit` 和 `withdraw` 方法添加了前置和后置操作
- 在 `Main` 类中，创建了一个银行账户实例，并将它传递给了一个账户代理实例。然后，我们使用 `Proxy.newProxyInstance` 方法创建一个动态代理对象，该对象实现了 `Account` 接口，并在其方法调用时会调用 `AccountProxy` 的 `invoke` 方法。最后，我们使用代理对象进行存款和取款操作

### 使用小结

代理模式在`Java`中的应用比较广泛，比如`Spring`的`AOP`实现、远程`RPC`调用等。代理模式可以在不修改原始接口的情况下，对目标对象进行增强或者替换

## 外观模式（Facade Pattern）

外观模式是一种结构型设计模式，它提供了一个简单的接口，隐藏了一组复杂的子系统的复杂性，使得客户端可以更容易地使用这个子系统。

  外观模式的核心思想是通过提供一个简化的接口，将系统的复杂性封装起来，从而降低系统的耦合性，并使得系统更易于维护和扩展。

### 使用场景

- 系统中包含多个模块，每个模块都有自己的接口和实现，需要对外提供一个统一的接口
- 系统中存在多个复杂的对象或类，需要对外提供简单的接口
- 需要解耦系统的各个组件，使得它们可以独立变化
- 需要隔离系统的变化，使得系统的不同模块可以独立变化

### 代码实现

- 一个常见的外观模式的例子是电脑开机过程。在电脑开机的过程中，有许多子系统需要被初始化，例如 CPU、内存、硬盘等等。如果每个子系统都要直接与客户端进行交互，那么客户端的代码会非常复杂
- 使用外观模式可以将所有子系统的初始化过程封装到一个简单的接口中，从而使得客户端只需要与外观对象交互，就可以完成所有的初始化过程

```java
// CPU 子系统
public class CPU {
    public void start() {
        System.out.println("CPU is starting...");
    }
}

// 内存子系统
public class Memory {
    public void start() {
        System.out.println("Memory is starting...");
    }
}

// 硬盘子系统
public class HardDrive {
    public void start() {
        System.out.println("HardDrive is starting...");
    }
}

// 外观类
public class Computer {
    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;

    public Computer() {
        cpu = new CPU();
        memory = new Memory();
        hardDrive = new HardDrive();
    }

    // 提供一个简单的接口，封装了所有子系统的初始化过程
    public void start() {
        System.out.println("Computer is starting...");
        cpu.start();
        memory.start();
        hardDrive.start();
        System.out.println("Computer has started...");
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.start();
    }
}
```

+ 在这个例子中，`CPU`、`Memory`、`HardDrive` 分别代表电脑开机过程中的 CPU、内存、硬盘子系统，`Computer` 则是外观类，它封装了所有子系统的初始化过程，提供了一个简单的 `start` 方法。客户端只需要与 `Computer` 对象交互即可完成电脑的开机过程，而不需要了解每个子系统的实现细节

### 使用小结

在Java中，外观模式经常被用于封装底层的复杂子系统，提供一个更加简单、易于使用的接口给上层模块调用

- `JDBC`是Java中访问关系型数据库的标准接口，它封装了许多与数据库操作相关的底层细节，使得程序员可以通过简单的接口来进行数据库操作。`JDBC`的`Connection、Statement、ResultSet`等接口和类就是外观模式的典型应用，它们提供了一个简单的接口，封装了与数据库底层的交互细节
- `Spring`其中的许多组件都使用了外观模式来隐藏底层的复杂性。例如，`Spring`中的`AOP`（面向切面编程）模块提供了一个简单的接口，封装了底层的动态代理、拦截器等复杂细节；`Spring`中的`JDBC`模块也提供了一个简单的接口，封装了与数据库操作相关的底层细节
- Java网络编程中的`Socket`类和`ServerSocket`类也是外观模式的典型应用，它们提供了一个简单的接口，封装了与网络通信相关的底层细节
- Java虚拟机中的类加载器、内存管理、线程调度等子系统都是外观模式的典型应用，它们提供了一个简单的接口，封装了与虚拟机底层相关的复杂细节

## 桥接模式（Bridge Pattern）

Java桥接模式（Bridge Pattern）是一种结构型设计模式，它将一个对象的抽象部分与它的实现部分分离，使它们可以独立地变化。桥接模式的目的是将抽象与实现解耦，从而实现系统的灵活性和可扩展性。

### 使用场景

- 当一个类存在多个实现版本时，可以使用桥接模式将其分离开来，从而使得这些实现版本可以独立地变化。
- 当需要将一个抽象部分与它的实现部分分离开来，以便它们可以独立地进行修改和扩展时，可以使用桥接模式。
- 当需要在抽象类中定义抽象方法，以便在不同的实现类中实现具体的行为时，可以使用桥接模式。
- 当需要在运行时动态地改变一个对象的实现时，可以使用桥接模式。
- 当需要将一个大类拆分成多个独立的层级时，可以使用桥接模式

### 代码实现

- 假设有一个图形绘制应用程序，它支持绘制不同颜色的图形。图形可以是矩形、圆形等等。我们可以使用桥接模式来将颜色和图形分离开来
- 首先，我们定义一个颜色接口 Color 和它的两个实现类 Red 和 Blue

```java
public interface Color {
    public void applyColor();
}

public class Red implements Color {
    @Override
    public void applyColor() {
        System.out.println("Applying red color");
    }
}

public class Blue implements Color {
    @Override
    public void applyColor() {
        System.out.println("Applying blue color");
    }
}
```

+ 然后，我们定义一个抽象的图形类 Shape，它包含一个颜色接口的引用

```java
public abstract class Shape {
    protected Color color;
    
    public Shape(Color color) {
        this.color = color;
    }
    
    public abstract void draw();
}
```

+ 接下来，定义两个实现类 `Rectangle` 和 `Circle`，它们继承自 `Shape` 类

```java
public class Rectangle extends Shape {
    public Rectangle(Color color) {
        super(color);
    }
    
    @Override
    public void draw() {
        System.out.print("Drawing rectangle. ");
        color.applyColor();
    }
}

public class Circle extends Shape {
    public Circle(Color color) {
        super(color);
    }
    
    @Override
    public void draw() {
        System.out.print("Drawing circle. ");
        color.applyColor();
    }
}
```

+ 现在，我们可以使用这些类来绘制不同颜色的图形

```java
Color red = new Red();
Color blue = new Blue();

Shape rectangle = new Rectangle(red);
rectangle.draw();//Drawing rectangle. Applying red color 

Shape circle = new Circle(blue);
circle.draw();//Drawing circle. Applying blue color
```

Shape 类充当桥接模式中的抽象部分，Color 接口充当实现部分。使用桥接模式，我们可以轻松地添加新的图形和颜色类，而不会影响现有的代码

### 使用小结

+ 一个经典的桥接模式例子是 JDBC API。在 JDBC API 中，`DriverManager` 充当桥接模式中的抽象部分，它负责管理多个 JDBC 驱动程序的实现部分。开发人员可以通过 `DriverManager` 类来连接数据库，而无需了解底层数据库驱动程序的具体实现

## 组合模式（Composite Pattern）

组合模式是一种结构型设计模式，它允许将对象组合成树形结构，以表示“部分-整体”的层次关系。组合模式可以让客户端使用统一的方式处理单个对象和组合对象，从而简化了客户端的代码。

### 使用场景

- 当需要表示一个对象的部分-整体层次结构时，可以使用组合模式。例如，可以使用组合模式来表示一个文件夹，它包含多个文件和其他文件夹。
- 当客户端代码需要统一地处理单个对象和组合对象时，可以使用组合模式。这样客户端代码可以使用相同的代码来处理单个对象和组合对象，而不需要进行特判。
- 当需要对树形结构进行递归遍历时，可以使用组合模式。组合模式可以让代码更加简洁，而且可以轻松地遍历整个树形结构
- 当需要动态地添加或删除树形结构中的子节点时，可以使用组合模式。组合模式可以让你方便地添加或删除子节点，而且不会影响其他节点的行

### 代码实现

以下是另一个使用Java组合模式的例子，它表示一个文件系统

```java
import java.util.ArrayList;
import java.util.List;

public class FileSystem {
    private String name;
    private boolean isFile;
    private List<FileSystem> children = new ArrayList<>();

    public FileSystem(String name, boolean isFile) {
        this.name = name;
        this.isFile = isFile;
    }

    public void add(FileSystem fileSystem) {
        children.add(fileSystem);
    }

    public void remove(FileSystem fileSystem) {
        children.remove(fileSystem);
    }

    public void display(int depth) {
        System.out.println("-".repeat(depth) + name);

        for (FileSystem fileSystem : children) {
            fileSystem.display(depth + 2);
        }
    }

    public static void main(String[] args) {
        FileSystem root = new FileSystem("C:", false);
        FileSystem windowsFolder = new FileSystem("Windows", false);
        FileSystem programFilesFolder = new FileSystem("Program Files", false);
        FileSystem notepadFile = new FileSystem("notepad.exe", true);
        FileSystem javaFolder = new FileSystem("Java", false);
        FileSystem eclipseFolder = new FileSystem("Eclipse", false);
        FileSystem eclipseExeFile = new FileSystem("eclipse.exe", true);

        root.add(windowsFolder);
        root.add(programFilesFolder);
        programFilesFolder.add(javaFolder);
        javaFolder.add(eclipseFolder);
        eclipseFolder.add(eclipseExeFile);
        windowsFolder.add(notepadFile);

        root.display(0);
    }
}
```

- 在这个例子中，`FileSystem`表示一个文件系统中的文件或文件夹，它有一个`name`属性和一个`isFile`属性，用于判断它是文件还是文件夹。`add`和`remove`方法用于添加或删除子节点，`display`方法用于递归地打印整个文件系统
- 在`main`方法中，我们创建了一个`C:`盘的文件系统，并添加了`Windows`文件夹、`Program Files`文件夹、`notepad.exe`文件、`Java`文件夹、`Eclipse`文件夹和`eclipse.exe`文件。我们将这些文件和文件夹按照层次结构组织起来，方便用户查看整个文件系统
- 运行这个程序会输出以下结果

```
C:
--Windows
----notepad.exe
--Program Files
----Java
------Eclipse
--------eclipse.exe
```

### 使用小结

组合模式可以用于处理具有树形结构的对象集合。比如组织架构图、文件系统、图形场景图等。使用组合模式可以方便地组合对象，以实现复杂的功能

## 享元模式（Flyweight Pattern）

享元模式是一种结构型设计模式，它通过共享对象来减少内存占用和提高系统性能。享元模式适用于大量细粒度的对象，这些对象具有相似的属性，而且这些属性可以被共享

在享元模式中，我们将对象分为两种

- 内部状态指对象共享的部分，可以被多个对象共享；
- 外部状态则指对象独有的部分，不能被共享。

  通过将内部状态抽取出来，我们可以减少系统中需要创建的对象数量，从而降低内存消耗。

### 使用场景

- 当一个应用程序需要创建大量的相似对象时，使用享元模式可以减少内存占用和提高系统性能
- 当一个对象的状态可以被拆分为内部状态和外部状态时，使用享元模式可以将内部状态共享，从而减少对象数量和内存消耗。
- 当一个应用程序需要使用缓存来提高性能时，可以使用享元模式来实现缓存功能，从而提高系统性能。

### 代码实现

- 使用享元模式实现一个简单的字符串存储库，它可以存储大量的字符串，同时尽可能节省内存
- 首先定义一个 `Flyweight` 接口，它表示共享的字符串对象。具体的字符串对象将实现这个接口

```java
public interface Flyweight {
    void print(String str);
}
```

+ 接下来，定义一个具体的 Flyweight 实现类，它包含一个字符串值和一个计数器，用于记录该字符串的使用次数

```java
public class ConcreteFlyweight implements Flyweight {
    private String value;
    private int count;

    public ConcreteFlyweight(String value) {
        this.value = value;
        this.count = 0;
    }

    @Override
    public void print(String str) {
        System.out.println("Printing " + value + " for " + str);
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

+ 然后，定义一个 `FlyweightFactory` 工厂类，它负责管理 `Flyweight` 对象并根据需要创建它们

```java
import java.util.HashMap;
import java.util.Map;

public class FlyweightFactory {
    private static final Map<String, Flyweight> flyweights = new HashMap<>();

    public static Flyweight getFlyweight(String value) {
        Flyweight flyweight = flyweights.get(value);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(value);
            flyweights.put(value, flyweight);
        }
        return flyweight;
    }
}
```

+ 最后，定义一个 `Client` 类，它负责使用 `Flyweight` 对象来存储字符串

```java
public class Client {
    public static void main(String[] args) {
        String[] strings = {"hello", "world", "hello", "java", "world"};

        for (String str : strings) {
            Flyweight flyweight = FlyweightFactory.getFlyweight(str);
            flyweight.print(str);
        }

        System.out.println("Flyweight count: " + FlyweightFactory.flyweights.size());
        for (Flyweight flyweight : FlyweightFactory.flyweights.values()) {
            System.out.println("String: " + ((ConcreteFlyweight) flyweight).value +
                    ", Count: " + ((ConcreteFlyweight) flyweight).getCount());
        }
    }
}
```

+ 在这个示例中，使用 `FlyweightFactory` 来管理共享的字符串对象。每个具体的 `Flyweight` 实现类都包含一个字符串值和一个计数器，用于记录该字符串的使用次数。当 `Client` 类使用 `FlyweightFactory` 来存储字符串时，它将创建或获取一个共享的 `Flyweight` 对象，并使用它来存储字符串。最后，我们可以查看 `FlyweightFactory` 中保存的所有 `Flyweight` 对象，以及它们的使用次数

### 使用小结

使用享元模式可以显著降低内存消耗并提高系统的性能。比如

- Java 中的字符串池是一个存储字符串对象的池子，可以共享字符串对象，而不是为每个字符串都创建一个新的实例。
- Java 中的数据库连接池可以缓存一些已经建立好的数据库连接，当需要使用数据库时，可以直接从连接池中获取连接，而不需要每次都创建一个新的连接。这样可以大大提高数据库的访问效率和性能

## 代理，装饰与适配器模式的区别

**定义**

代理模式：为其他对象提供一种代理以控制对这个对象的访问

装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活

适配器模式：把一个类的接口变换成客户端所期待的另一个接口，从而使原本因接口不匹配而无法工作的两个类能够在一起工作

**它们的主要区别在于**

- **代理模式的特点在于隔离**，隔离调用类和被调用类的关系，通过一个代理类去调用，因此代理模式不需要传入原有的对象，内部会持有原有对象的实现
- **装饰器模式特点在于增强**，他的特点是被装饰类和所有的装饰类必须实现同一个接口，而且必须持有被装饰的对象，可以无限装饰,被装饰对象通过构造函数传入
- **适配器的特点在于兼容**, 适配器模式需要实现新的接口，代理，装饰器模式是与原对象实现同一个接口，而适配器类则是匹配新接口

**总的来说就是如下三句话**

- 代理模式是将一个类(`a`)转换成具体的操作类(`b`)
- 装饰模式是在一个原有类(`a`)的基础之上增加了某些新的功能变成另一个类(`b`)
- 适配器模式是将一个类(`a`)通过某种方式转换成另一个类(`b`)

# 行为型模式

## 策略模式（Strategy Pattern）

- Java 策略模式是一种行为型设计模式，它定义了一系列的算法，将每个算法都封装起来，并使它们可以互相替换，从而使算法的变化不会影响到使用算法的客户端。这种模式可以使算法的变化更加灵活和可控，同时也可以提高代码的可读性和可维护性
- 通过使用策略模式，我们可以更灵活地实现不同的功能需求，并让用户根据实际情况选择最合适的策略进行操作

### 使用场景

- 当一个对象具有多种行为或算法，并且需要在运行时动态选择其中一种时，策略模式可以派上用场。
- 当需要对同一种行为或算法进行多种实现时，我们可以使用策略模式。
- 当需要减少大量的 if/else 语句时，我们可以使用策略模式来优化代码。

### 代码实现

- 假设有一个电商网站，它需要根据不同的促销策略来计算订单的价格。促销策略包括打折、满减、直降等等。

- 首先，我们定义一个促销策略接口，其中包含一个计算订单价格的方法


```java
public interface PromotionStrategy {
    double calculatePrice(double price);
}
```

+ 然后，我们实现具体的促销策略，例如打折、满减和直降策略

```java
public class DiscountPromotionStrategy implements PromotionStrategy {
    private double discount;

    public DiscountPromotionStrategy(double discount) {
        this.discount = discount;
    }

    public double calculatePrice(double price) {
        return price * (1 - discount);
    }
}

public class FullReductionPromotionStrategy implements PromotionStrategy {
    private double threshold;
    private double reduction;

    public FullReductionPromotionStrategy(double threshold, double reduction) {
        this.threshold = threshold;
        this.reduction = reduction;
    }

    public double calculatePrice(double price) {
        return price >= threshold ? price - reduction : price;
    }
}

public class DirectReductionPromotionStrategy implements PromotionStrategy {
    private double reduction;

    public DirectReductionPromotionStrategy(double reduction) {
        this.reduction = reduction;
    }

    public double calculatePrice(double price) {
        return price - reduction;
    }
}
```

+ 最后，我们定义一个订单类，其中包含一个 PromotionStrategy 对象和一个 calculatePrice 方法

```java
public class Order {
    private double price;
    private PromotionStrategy promotionStrategy;

    public Order(double price, PromotionStrategy promotionStrategy) {
        this.price = price;
        this.promotionStrategy = promotionStrategy;
    }

    public double calculatePrice() {
        return promotionStrategy.calculatePrice(price);
    }
}
```

+ 创建一个订单，并指定不同的促销策略来计算订单价格

```java
Order order = new Order(100, new DiscountPromotionStrategy(0.1));
double price = order.calculatePrice(); // 90

order = new Order(200, new FullReductionPromotionStrategy(150, 50));
price = order.calculatePrice(); // 150

order = new Order(300, new DirectReductionPromotionStrategy(50));
price = order.calculatePrice(); // 250
```

使用小结

策略模式是 Java 中经常使用的一种设计模式，它可以在很多场景中使用，比如

- 可以使用策略模式定义多种日志记录方式（例如控制台输出、文件输出、网络传输等）并动态选择使用哪种方式进行日志记录。
- 可以使用策略模式定义多种支付方式（例如微信支付、支付宝支付、银行卡支付等）并让用户动态选择使用哪种支付方式进行支付。
- 可以使用策略模式定义多种加密算法（例如对称加密、非对称加密、哈希算法等）并让用户动态选择使用哪种加密算法进行数据加密。

## 模板方法模式Template Method Pattern）

Java 模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，并将一些步骤延迟到子类中实现。模板方法模式使得子类可以在不改变算法结构的情况下重定义算法中的某些步骤。

### 使用场景

- 算法骨架固定：如果一个算法的基本结构已经固定，但具体的实现步骤可能因为不同的场景而不同，这个时候可以使用模板方法模式。
- 实现代码复用：如果有多个类的某些方法结构相似，但是实现细节不同，这个时候可以将这些相同的结构抽象到父类中，由子类来实现不同的细节。
- 简化代码实现：模板方法模式可以将复杂的代码实现分离成几个简单的步骤，从而降低代码实现的难度和复杂度。
- 框架和库的设计：模板方法模式是设计框架和库的重要方式之一，它可以提供统一的接口和标准的实现流程，方便用户进行扩展和定制

### 代码实现

- `AbstractClass` 是一个抽象类，它定义了算法的骨架，其中 `templateMethod()` 是模板方法，它定义了算法的流程，由一些抽象方法 `primitiveOperation1()` 和 `primitiveOperation2()` 组成
- `ConcreteClass` 是 `AbstractClass` 的具体子类，它实现了抽象方法，定义了具体的算法细节。在客户端使用时，创建 `ConcreteClass` ，然后调用其 `templateMethod()` 方法，即可完成算法的执行

```java
// 抽象类，定义算法骨架
public abstract class AbstractClass {
    
    // 模板方法，定义算法流程
    public final void templateMethod() {
        primitiveOperation1();
        primitiveOperation2();
    }

    // 抽象方法1，由子类实现
    public abstract void primitiveOperation1();

    // 抽象方法2，由子类实现
    public abstract void primitiveOperation2();
}

// 具体子类，实现具体的算法细节
public class ConcreteClass extends AbstractClass {
    
    @Override
    public void primitiveOperation1() {
        System.out.println("ConcreteClass.primitiveOperation1()");
    }

    @Override
    public void primitiveOperation2() {
        System.out.println("ConcreteClass.primitiveOperation2()");
    }
}

// 客户端使用
public class Client {
    
    public static void main(String[] args) {
        AbstractClass abstractClass = new ConcreteClass();
        abstractClass.templateMethod();
    }
}
```

+ 需要注意的是，在模板方法模式中，模板方法通常被声明为 `final`，以防止子类对其进行重写。同时，由于模板方法是一个抽象方法，因此在实现时需要注意不同抽象方法的实现顺序，以确保算法的正确性

### 使用小结

+ 很多框架类的设计都采用了模板方法模式，例如 Spring 中的 `JdbcTemplate`，其中定义了一套执行 SQL 的流程，并由子类实现具体的 SQL 语句

## 观察者模式（Observer Pattern）

观察者模式是一种行为型模式，它定义了对象之间的一种一对多的依赖关系。在这种模式中，一个对象发生变化时，所有依赖于它的对象都会得到通知并自动更新。观察者模式可以帮助开发人员创建可扩展的应用程序，减少对象之间的直接依赖关系

### 应用场景

- 事件处理机制：`Java`中的`Swing GUI`框架就是基于观察者模式实现的，当用户与组件交互时，组件会向注册的监听器发送事件通知，以触发相应的事件处理方法。
- 日志记录：`Java`中的日志系统也是基于观察者模式实现的，当日志发生变化时，它会通知所有注册的观察者，例如文件输出流、控制台输出流等，从而实现日志的输出和记录。
- 用户界面设计：在`Java`中，用户界面设计中的许多元素都可以使用观察者模式实现，例如菜单项、按钮、文本框等，当用户与这些元素交互时，它们会向注册的监听器发送事件通知，以触发相应的事件处理方法。
- 多线程编程：在`Java`中，观察者模式还可以用于多线程编程中，当一个线程发生了某些变化时，它可以向其他线程发送通知，以实现线程间的协作和同步

### 代码实现

- 这个示例中，`ConcreteSubject` 实现了 `Subject` 接口，它维护了一个 `observers` 列表，用于保存注册的观察者对象。当被观察者发生变化时，它会遍历观察者列表，调用每个观察者的 `update` 方法
- `ConcreteObserver` 实现了 `Observer` 接口，它可以接收来自被观察者的通知，并执行相应的操作
- 在测试类 `ObserverPatternDemo` 中，我们创建了一个具体的被观察者对象 `ConcreteSubject`，并册了两个具体的观察者对象 `observer1` 和 `observer2`。当被观察者发生变化时，它会通知所有注册的观察者对象，并调用它们的 `update` 方法

```java
// 观察者接口
interface Observer {
    void update(String message);
}

// 被观察者接口
interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers(String message);
}

// 具体的被观察者实现类
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 具体的观察者实现类
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}

// 测试类
public class ObserverPatternDemo {
    public static void main(String[] args) {
        Subject subject = new ConcreteSubject();
        Observer observer1 = new ConcreteObserver("Observer1");
        Observer observer2 = new ConcreteObserver("Observer2");
        subject.registerObserver(observer1);
        subject.registerObserver(observer2);
        subject.notifyObservers("Hello, World!");
    }
}
```

### 使用小结

- 观察者模式的优点在于它提供了一种松耦合的方式，让观察者和主题之间的依赖关系变得更加灵活，同时也可以使得程序更易于扩展和维护
- 观察者模式的应用场景包括：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面时；当一个对象的改变需要同时改变其他对象的时候；当一个对象的改变需要通知其他对象而又不希望与被通知对象形成紧耦合关系时

## 迭代器模式Iterator Pattern）

迭代器模式是一种行为设计模式，它提供一种统一的方法来遍历一个容器中的所有元素，而不用暴露容器的内部结构

使用迭代器模式可以将遍历容器和容器本身的实现分离开来，从而可以在不影响容器的情况下更改遍历算法。此外，迭代器模式可以简化遍历代码，并提供更加通用的遍历方法

### 使用场景

- 需要遍历一个容器中的所有元素，但是不想暴露容器的内部结构。
- 需要提供一个通用的遍历方法，而不需要知道容器的具体实现细节。
- 需要支持多种不同的遍历方式，例如正序、倒序、随机等。
- 需要对容器的遍历算法进行更改，但是不想影响容器本身的实现。
- 需要在遍历过程中同时进行修改操作

### 代码实现

- 下面是一个使用`Java`迭代器模式的简单例子，以遍历一个名字列表为例
- 首先定义一个名字列表接口，包含两个方法：添加名字和获取迭代器

```java
public interface NameList {
    void addName(String name);
    Iterator<String> iterator();
}
```

- 然后定义一个名字列表实现类，实现添加名字和获取迭代器的方法
- 在这个实现类中，定义了一个内部类 `NameIterator`，实现了 `Iterator` 接口中的 `hasNext、next 和 remove `方法

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class NameListImpl implements NameList {
    private List<String> names = new ArrayList<>();

    public void addName(String name) {
        names.add(name);
    }

    public Iterator<String> iterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator<String> {
        private int index = 0;

        public boolean hasNext() {
            return index < names.size();
        }

        public String next() {
            return names.get(index++);
        }

        public void remove() {
            names.remove(--index);
        }
    }
}
```

+ 下面是一个使用迭代器遍历名字列表的示例代码

```java
public class IteratorDemo {
    public static void main(String[] args) {
        NameList nameList = new NameListImpl();
        nameList.addName("Alice");
        nameList.addName("Bob");
        nameList.addName("Charlie");

        Iterator<String> iterator = nameList.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

### 使用小结

在`Java`中，迭代器模式已经被广泛应用在集合类中。`Java`集合类中都实现了`Iterator`接口，提供了一种通用的迭代器实现方式，可以方便地遍历集合中的所有元素

## 责任链模式（Chain of Responsibility Pattern）

责任链模式是一种行为型设计模式，它允许多个对象来处理请求，并且将这些对象连成一条链。当请求到来时，它会依次经过链上的对象，直到有一个对象能够处理请求为止

责任链模式和[过滤器模式](https://juejin.cn/post/7199907126688825400#heading-32)都是行为型设计模式，它们的主要目的是将处理请求的对象组织成一个链，并让请求沿着这个链传递，直到找到能够处理该请求的对象为止

> 那他们有什么区别吗？
>
> - 用途不同：责任链模式的主要目的是让多个对象都有机会处理同一个请求，而过滤器模式的主要目的是在一个对象中实现多个过滤器，并依次对请求进行处理。
> - 处理方式不同：责任链模式中，每个处理器都会判断自己是否能够处理请求，如果可以则处理请求，并将请求传递给下一个处理器；如果不能处理，则将请求传递给下一个处理器。而过滤器模式中，每个过滤器都是独立的，它们按照一定的顺序依次处理请求，如果某个过滤器不能处理请求，则直接返回。
> - 对象关系不同：责任链模式中，处理器之间通常是单向关系，即每个处理器只知道下一个处理器是谁，而不知道上一个处理器是谁。而过滤器模式中，过滤器之间通常是相互独立的，它们不需要知道彼此的存在。
> - 实现方式不同：责任链模式通常是通过继承或组合的方式实现的，而过滤器模式通常是通过组合的方式实现的。

### 使用场景

  责任链模式通常用于以下场景：

- 请求的处理涉及多个对象，并且处理流程需要按顺序进行。
- 请求的处理方式需要动态决定，或者需要在不同时间处理请求。
- 在请求处理过程中，需要将请求拆分成多个部分分别处理，最后将它们合并。
- 需要在不影响客户端的情况下增强处理流程。
- 需要在系统中动态添加或删除处理器。
- 处理器之间需要解耦，避免它们之间的直接依赖关系。

### 代码实现

假设我们有一个处理`HTTP`请求的框架，其中有多个过滤器（`Filter`），每个过滤器都可以对请求进行处理，如果当前的过滤器不能处理请求，就将请求交给下一个过滤器。代码如下

```java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain chain);
}

public class FilterA implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain chain) {
        System.out.println("过滤器A处理请求");
        // 处理请求
        chain.doFilter(request, response);
        // 处理响应
    }
}

public class FilterB implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain chain) {
        System.out.println("过滤器B处理请求");
        // 处理请求
        chain.doFilter(request, response);
        // 处理响应
    }
}

public class FilterChain {
    private List<Filter> filters = new ArrayList<>();
    private int index = 0;

    public void addFilter(Filter filter) {
        filters.add(filter);
    }

    public void doFilter(Request request, Response response) {
        if (index == filters.size()) {
            return;
        }
        Filter filter = filters.get(index);
        index++;
        filter.doFilter(request, response, this);
    }
}

public class Request {}
public class Response {}

public class Main {
    public static void main(String[] args) {
        Request request = new Request();
        Response response = new Response();

        FilterChain chain = new FilterChain();
        chain.addFilter(new FilterA());
        chain.addFilter(new FilterB());

        chain.doFilter(request, response);
    }
}
```

定义了一个Filter接口和两个实现类 `FilterA` 和 `FilterB` ，它们都可以对请求进行处理。我们还定义了一个 `FilterChain` 类，它持有所有的过滤器，当请求到来时，它会依次将请求交给每个过滤器进行处理，直到有一个过滤器能够处理请求为止

```
过滤器A处理请求
过滤器B处理请求
```

### 使用小结

责任链模式在Java中应用场景比较广泛，例如：

- 在`Java Servlet`框架中，请求被 `Servlet `容器传递给过滤器链，每个过滤器都可以对请求进行处理，如果需要将请求传递给下一个过滤器，则需要调用`chain.doFilter()`方法，直到最终到达`Servlet`为止。
- 在`Spring`框架中，责任链模式被广泛应用于`AOP`和数据源路由等方面。在`AOP`方面，每个切面可以定义多个切点，并且可以定义切点的顺序，每个切点都可以对方法进行前置或后置处理，或者抛出异常；在数据源路由方面，可以根据不同的业务需求，将请求路由到不同的数据源进行处理。
- 在`MyBatis`框架中，责任链模式被用于`SQL`解析和`SQL`执行等方面。在解析方面，将SQL解析成`AST(Abstract Syntax Tree)`树，并且可以通过责任链模式，将不同的解析器组合起来，实现多种SQL语法的解析

## 命令模式（Command Pattern）

Java命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而使您可以将不同的请求参数化，将它们放入队列中，或者将请求记录在日志中，以及支持可撤销的操作。这种模式的主要组成部分包括命令接口、具体命令、调用者和接收者。

### 使用场景

- 当需要将请求发送者和接收者解耦时，可以使用命令模式，因为命令对象充当请求发送者和接收者之间的媒介。
- 当需要支持命令的撤销（undo）操作时，可以使用命令模式，因为每个命令对象都可以保存执行所需的状态。
- 当需要在不同的时间指定、排队或记录请求时，可以使用命令模式，因为命令对象可以像其他对象一样传递、存储和操作。
- 当需要实现日志记录功能时，可以使用命令模式，因为命令对象可以保存操作的历史记录，以便将来需要时进行检查和恢复。
- 当需要将一组简单的操作组合成更复杂的操作时，可以使用命令模式，因为您可以将多个命令组合成一个复合命令。

### 代码实现

- 假设有一个电视机，它具有开机、关机和切换频道等操作

- 定义命令接口和具体命令类


```java
public interface Command {
    void execute();
}

public class TvOnCommand implements Command {
    private TV tv;
    
    public TvOnCommand(TV tv) {
        this.tv = tv;
    }
    
    public void execute() {
        tv.on();
    }
}

public class TvOffCommand implements Command {
    private TV tv;
    
    public TvOffCommand(TV tv) {
        this.tv = tv;
    }
    
    public void execute() {
        tv.off();
    }
}

public class TvChangeChannelCommand implements Command {
    private TV tv;
    private int channel;
    
    public TvChangeChannelCommand(TV tv, int channel) {
        this.tv = tv;
        this.channel = channel;
    }
    
    public void execute() {
        tv.changeChannel(channel);
    }
}
```

+ 定义接收者类

```java
public class TV {
    public void on() {
        System.out.println("TV is on");
    }
    
    public void off() {
        System.out.println("TV is off");
    }
    
    public void changeChannel(int channel) {
        System.out.println("TV channel is changed to " + channel);
    }
}
```

+ 定义调用者类

```java
public class RemoteController {
    private Command onCommand;
    private Command offCommand;
    private Command changeChannelCommand;
    
    public RemoteController(Command onCommand, Command offCommand, Command changeChannelCommand) {
        this.onCommand = onCommand;
        this.offCommand = offCommand;
        this.changeChannelCommand = changeChannelCommand;
    }
    
    public void turnOn() {
        onCommand.execute();
    }
    
    public void turnOff() {
        offCommand.execute();
    }
    
    public void changeChannel() {
        changeChannelCommand.execute();
    }
}
```

+ 使用命令模式

```java
TV tv = new TV();
Command onCommand = new TvOnCommand(tv);
Command offCommand = new TvOffCommand(tv);
Command changeChannelCommand = new TvChangeChannelCommand(tv, 2);

RemoteController remoteController = new RemoteController(onCommand, offCommand, changeChannelCommand);
remoteController.turnOn(); // 输出 "TV is on"
remoteController.turnOff(); // 输出 "TV is off"
Command changeChannelCommand2 = new TvChangeChannelCommand(tv, 5);
RemoteController remoteController2 = new RemoteController(onCommand, offCommand, changeChannelCommand2);
remoteController2.changeChannel(); // 输出 "TV channel is changed to 5"
```

上述代码中，`RemoteController` 充当了调用者角色，`TvOnCommand、TvOffCommand` 和 `TvChangeChannelCommand` 充当了具体命令角色，而 `TV `充当了接收者角色。

  当 `RemoteController` 调用某个命令的` execute()` 方法时，具体命令将通过接收者`TV`来执行相应的操作。通过这种方式，调用者和接收者之间的耦合得以解除。

### 使用小结

- 可以使用命令模式来实现撤销和恢复操作。例如，在编辑器中，可以使用命令模式来实现对文本的撤销和恢复操作。
- 可以使用命令模式来实现日志记录。例如，在Web应用中，可以将每个请求封装成一个命令对象，并将命令对象记录到日志文件中。
- 可以使用命令模式来实现消息队列。例如，在JMS（Java消息服务）中，可以将每个消息封装成一个命令对象，并将命令对象加入到消息队列中

## 状态模式（State Pattern）

Java 状态模式是一种行为设计模式，它允许对象在内部状态改变时改变它的行为。状态模式通过将状态封装成一个对象来实现这一点，从而使得一个对象的行为取决于它的状态对象，而不是取决于对象本身。

### 使用场景

- 当一个对象的行为取决于它的状态，并且该对象的状态可能在运行时发生改变时，可以使用状态模式。
- 当一个对象需要根据不同的状态采取不同的行动时，可以使用状态模式。
- 当一个对象的代码中包含大量与状态相关的条件语句时，可以使用状态模式来简化代码。

### 代码实现

- 假设有一个订单对象，订单状态包括 "新建"、"处理中" 和 "完成" 三种状态，订单状态会随着订单处理的不同而改变

- 首先，我们需要定义订单状态的接口


```java
public interface OrderState {
    void processOrder(Order order);
}
```

+ 然后，我们定义订单状态的具体实现类，分别对应三种不同的状态

```java
public class NewOrder implements OrderState {
    public void processOrder(Order order) {
        // 处理新建状态下的订单
        System.out.println("Processing new order.");
        order.setState(new ProcessingOrder());
    }
}

public class ProcessingOrder implements OrderState {
    public void processOrder(Order order) {
        // 处理处理中状态下的订单
        System.out.println("Processing order in progress.");
        order.setState(new CompletedOrder());
    }
}

public class CompletedOrder implements OrderState {
    public void processOrder(Order order) {
        // 处理完成状态下的订单
        System.out.println("Processing completed order.");
    }
}
```

+ 最后，我们定义订单对象，并在订单对象中实现状态的切换

```java
public class Order {
    private OrderState state;

    public Order() {
        state = new NewOrder();
    }

    public void setState(OrderState state) {
        this.state = state;
    }

    public void processOrder() {
        state.processOrder(this);
    }
}
```

+ 使用上面定义的订单对象和订单状态对象来处理订单了

```java
Order order = new Order();
order.processOrder();    // Output: Processing new order.
order.processOrder();    // Output: Processing order in progress.
order.processOrder();    // Output: Processing completed order.
```

+ 使用了状态模式来实现订单对象的状态转换，可以动态地改变订单对象的状态，并且无需修改订单对象本身的代码。使代码更加灵活和易于维护

### 使用小结

+ 状态模式在 Java 中的应用非常广泛，比如，线程池也是一个常见的状态机。通过使用状态模式，我们可以轻松地管理线程池的状态，并实现线程池状态的动态变更

## 备忘录模式（Memento Pattern）

备忘录模式是一种设计模式，它允许在不破坏封装性的情况下保存和恢复对象的状态。这种模式通常用于需要提供撤销或恢复操作的应用程序中

### 使用场景

- 需要提供撤销操作的应用程序，例如文本编辑器等。在这种情况下，备忘录模式可以用于保存对象的历史状态，并在需要时恢复对象的状态。
- 需要保存对象状态以进行后续恢复的应用程序。例如，游戏保存和恢复状态。
- 需要在不破坏对象封装性的情况下保存和恢复对象状态的应用程序。
- 需要跟踪和记录对象状态变化的应用程序。例如，监控和记录系统状态变化。

### 代码实现

假设我们有一个文本编辑器类，需要提供撤销和恢复操作

```java
import java.util.Stack;

public class TextEditor {
    private String text;
    private Stack<TextEditorMemento> undoStack;
    private Stack<TextEditorMemento> redoStack;

    public TextEditor(String text) {
        this.text = text;
        this.undoStack = new Stack<>();
        this.redoStack = new Stack<>();
    }

    public void setText(String text) {
        undoStack.push(new TextEditorMemento(this.text));
        this.text = text;
        redoStack.clear();
    }

    public String getText() {
        return text;
    }

    public void undo() {
        if (!undoStack.isEmpty()) {
            redoStack.push(new TextEditorMemento(this.text));
            this.text = undoStack.pop().getText();
        }
    }

    public void redo() {
        if (!redoStack.isEmpty()) {
            undoStack.push(new TextEditorMemento(this.text));
            this.text = redoStack.pop().getText();
        }
    }

    private static class TextEditorMemento {
        private final String text;

        public TextEditorMemento(String text) {
            this.text = text;
        }

        public String getText() {
            return text;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        TextEditor editor = new TextEditor("Hello World");

        System.out.println(editor.getText()); // output: Hello World

        editor.setText("Goodbye World");
        System.out.println(editor.getText()); // output: Goodbye World

        editor.undo();
        System.out.println(editor.getText()); // output: Hello World

        editor.redo();
        System.out.println(editor.getText()); // output: Goodbye World
    }
}
```

`TextEditor`是文本编辑器类，它有一个文本属性`text`，并且有两个栈`undoStack`和`redoStack`，用于保存备忘录。`setText()`方法用于设置文本，并将旧的文本备份到`undoStack`中。`undo()`方法用于撤销操作，从`undoStack`中取出上一个备忘录，并将当前文本备份到`redoStack`中。`redo()`方法用于恢复操作，从`redoStack`中取出上一个备忘录，并将当前文本备份到`undoStack`中

使用小结

通过使用备忘录模式，我们可以轻松地提供撤销和恢复操作，同时保持其封装性和简洁性。如果需要实现多次撤销和恢复操作，我们只需要保存多个备忘录即可

## 中介者模式（Mediator Pattern）

中介者模式用于降低多个对象之间的耦合，通过将多个对象之间的通信封装在一个中介者对象中来实现。中介者对象可以独立地管理对象之间的交互，并且可以让这些对象互相通信而不必显示地引用彼此

### 使用场景

- 多个对象之间存在复杂的相互关系，但是它们的交互逻辑比较分散和混乱
- 当一个对象需要和其他多个对象进行交互时，如果每个对象都直接和他对象进行交互，那么会产生复杂的调用关系，导致代码难以维护和扩展
- 当一个对象的改变会影响到其他多个对象的状态时，如果每个对象都需要手动处理状态变化，那么也会产生复杂的交互逻辑和调用关系

### 代码实现

- 假设正在开发一个聊天室应用程序，我们可以使用中介者模式来协调多个聊天用户之间的交互。在这个应用程序中，每个聊天用户都可以发送消息给其他用户，而中介者将负责将这些消息传递给其他用户。
- 具体实现中，我们可以定义一个中介者接口，其中包含一个发送消息的方法。然后我们可以创建一个具体的中介者实现，该实现将负责将消息从一个聊天用户传递到另一个聊天用户。我们还需要创建一个聊天用户接口和具体的聊天用户实现，以便我们可以让多个聊天用户加入到中介者中，并相互交互。
- 以下是一个简单的 Java 中介者模式示例，其中包含一个中介者接口（`ChatMediator`），聊天用户接口（`ChatUser`）和具体实现（`UserImpl`），以及一个具体的中介者实现（`ChatMediatorImpl`）

```java
// 中介者接口
public interface ChatMediator {
    void sendMessage(String message, ChatUser user);
}

// 聊天用户接口
public interface ChatUser {
    void receiveMessage(String message);
    void sendMessage(String message);
}

// 具体的聊天用户实现
public class UserImpl implements ChatUser {
    private ChatMediator mediator;
    private String name;

    public UserImpl(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println(name + " received message: " + message);
    }

    @Override
    public void sendMessage(String message) {
        mediator.sendMessage(message, this);
    }
}

// 具体的中介者实现
public class ChatMediatorImpl implements ChatMediator {
    private List<ChatUser> users;

    public ChatMediatorImpl() {
        this.users = new ArrayList<>();
    }

    @Override
    public void sendMessage(String message, ChatUser user) {
        for (ChatUser u : users) {
            if (u != user) {
                u.receiveMessage(message);
            }
        }
    }

    public void addUser(ChatUser user) {
        users.add(user);
    }
}

// 测试代码
public class MediatorPatternDemo {
    public static void main(String[] args) {
        ChatMediator mediator = new ChatMediatorImpl();

        ChatUser user1 = new UserImpl(mediator, "Alice");
        ChatUser user2 = new UserImpl(mediator, "Bob");
        ChatUser user3 = new UserImpl(mediator, "Charlie");

        mediator.addUser(user1);
        mediator.addUser(user2);
        mediator.addUser(user3);

        user1.sendMessage("Hi, everyone!");
        user2.sendMessage("Hello, Alice.");
        user3.sendMessage("What's up, guys?");
    }
}
```

+ 控制台输出

```java
Bob received message: Hi, everyone!
Charlie received message: Hi, everyone!
Alice received message: Hello, Alice.
Charlie received message: Hello, Alice.
Alice received message: What's up, guys?
Bob received message: What's up, guys?
```

### 使用小结

- 在`MVC`框架中，中介者模式被广泛使用，模型和视图之间的通信和控制都可以通过中介者来实现，降低模块之间的耦合度，提高整个系统的可维护性和可扩展性
- 中介者模式将复杂的交互转化为中介者对象和其他对象之间的简单交互，从而使系统易于维护和扩展

## 解释器模式（Interpreter Pattern）

解释器模式是一种行为型设计模式，它定义了一种语言语法，以及解释器，可以解释这种语法。解释器模式通常用于编译器、解析器、表达式计算器等领域。例如，正则表达式引擎就是一个常见的使用解释器模式的例子。

### 使用场景

- 当有一个语言需要解释执行，并且可以将该语言表示为一个抽象语法树时，解释器模式是一个很好的选择
- 当需要处理一些规则或配置时，解释器模式也可以作为一种替代方案。例如，编写一个计算器程序时，可以使用解释器模式来处理表达式
- 当需要实现一些复杂的规则或策略时，解释器模式也是一种不错的选择。例如，编写一个自然语言处理程序时，可以使用解释器模式来解析和理解语言的语法结构

### 代码实现

下面是一个简单的Java解释器模式的例子，用于计算加法表达式的值

```java
interface Expression {
    int interpret();
}

class NumberExpression implements Expression {
    private final int number;

    public NumberExpression(int number) {
        this.number = number;
    }

    @Override
    public int interpret() {
        return number;
    }
}

class PlusExpression implements Expression {
    private final Expression leftExpression;
    private final Expression rightExpression;

    public PlusExpression(Expression leftExpression, Expression rightExpression) {
        this.leftExpression = leftExpression;
        this.rightExpression = rightExpression;
    }

    @Override
    public int interpret() {
        return leftExpression.interpret() + rightExpression.interpret();
    }
}

class InterpreterDemo {
    public static void main(String[] args) {
        Expression expression = new PlusExpression(new NumberExpression(1), new NumberExpression(2));
        System.out.println(expression.interpret()); // Output: 3
    }
}
```

这里定义了两种表达式：`NumberExpression`表示一个数字，`PlusExpression`表示加法表达式。`PlusExpression`包含左表达式和右表达式，它们可以是数字或其他表达式。`interpret`方法用于计算表达式的值

在实际应用中，解释器模式可能会更加复杂，但这个例子可以帮助我们了解解释器模式的基本思想和实现方式

### 使用小结

在`Java`中，解释器模式常常应用于编译器、正则表达式、模板引擎、SQL解析器等方面。常用的`Java`模板引擎，如`FreeMarker和Thymeleaf`等，都是基于解释器模式实现的

**解释器模式的缺点是**：它可能会导致类的数量增加，并且在解析复杂的语法时，可能会导致性能问题。因此，在选择解释器模式时，需要考虑这些因素



