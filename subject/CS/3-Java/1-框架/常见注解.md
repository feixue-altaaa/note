# 注解的实现原理

## why

注解也被称为**元数据**

以前的框架流行的是xml配置，而现在更多的是用注解。主流的Spring开发都是全注解开发

## what

### 内置注解

java.lang提供的基础注解：

- `@Deprecated`：表示代码被弃用
- `@SuppressWarnings`：表示关闭编译器警告信息 有参数，直接用（all）吧
- `@Override`：表示方法被覆写

JAVA8新增：

`@FunctionalInterface`：表示一个函数式接口

### 元注解

**元注解**： 是针对 `public @interface Annotation {}` 自己实现注解时用到的基础注解

1. `@targert` 表示可以修饰什么内容
2. `@Retention & @RetentionTarget` 表示注解在它所修饰的类中可以被保留到何时，注解的生命周期
3. `@Inherited` 表示被该注解修饰的类 的子类 会一起继承该注解
4. `@Documented`：注解是否应当被包含在 JavaDoc 文档中

##### **`@target`取值：**

注：可以用`{}`多选

- ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上
- ElementType.FIELD：允许作用在属性字段上
- ElementType.METHOD：允许作用在方法上
- ElementType.PARAMETER：允许作用在方法参数上
- ElementType.CONSTRUCTOR：允许作用在构造器上
- ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上
- ElementType.ANNOTATION_TYPE：允许作用在注解上
- ElementType.PACKAGE：允许作用在包上

##### **`@Retention`取值：**

- RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件
- RetentionPolicy.CLASS：类加载阶段丢弃，在class文件的属性表中用 **RuntimeInvisibleAnnotations**表示
- RetentionPolicy.RUNTIME：**永久保存，可以反射获取，一般自定义注解都是RUNTIME**，在class文件的属性表中用**RuntimeVisibleAnnotations** 表示

##### Java8新增的元注解

**@Repeatable** ：使用这个注解时，可以多次修饰

**@Native** ：注解修饰成员变量：表示这个变量可以被本地代码引用，不常用

## 自定义注解

定义注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyMethodAnnotation {
 public String title() default "";
 public String description() default "";
}
```

使用注解

```java
@MyMethodAnnotation(title = "xxx", description = "xxx")
     public String xxx() {
         return "";
     }
```

获取注解

```java
public static void main(String[] args) {
  try {
      // 获取所有methods
      Method[] methods = TestMethodAnnotation.class.getClassLoader()
              .loadClass(("com.pdai.java.annotation.TestMethodAnnotation"))
              .getMethods();

      // 遍历
      for (Method method : methods) {
         // 方法上是否有MyMethodAnnotation注解
         if (method.isAnnotationPresent(MyMethodAnnotation.class)) {
                 // 获取MyMethodAnnotation对象信息
                 MyMethodAnnotation methodAnno = method
                         .getAnnotation(MyMethodAnnotation.class);
              // 访问注解的属性
                 System.out.println(methodAnno.title());
         }
     }
```

## 原理

java注解到底是什么？ 是类 还是接口，还是抽象类 ，在java里面是怎么生效的？

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test2 {
 public String title() default "";
 public String description() default "";
}
```

通过idea的查看[类继承](https://so.csdn.net/so/search?q=类继承&spm=1001.2101.3001.7020)关系的功能，可以看到@Test2继承了Annotation 接口

![在这里插入图片描述](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408181239354.png)

Annotation 可以在jdk包里面找到，它是所有注解的父接口

现在我们知道 注解是一个继承了Annotation的东西，那么@Test2 到底是类，还是接口，还是抽象类？

那么去字节码中找答案，自定义注解之后，我们需要在某个时刻将注解取出来，好取出来注解里面的值

![在这里插入图片描述](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408181240687.png)

这里通过 AnnotionTest.class.getDeclaredAnnotation(Test2.class);方法 获取到注解Test2 的实例 test2，然后调用其test2.value()方法。

在字节码中 ，可以看到调用的指令为 INVOKEINTERFACE指令

在jvm中 方法调用的指令有如下四种
```
invokestatic:调用静态方法，解析阶段确定唯一方法版本

invokespecial：调用<init> 方法，私有及显式调用父类方法，解析阶段确定唯一方法版本

invokevirtual：调用所有虚方法，隐式final 修饰的方法

invokerinterface:调用接口方法
```

因此，java编译器认为 value（）方法为一个接口方法， 因为如果是抽象类，那么就是用的invokevirual指令 

截止目前，我们知道了注解是一个接口，一个继承自Annotation的接口。 里面每一个属性，其实就是接口的一个抽象方法

那么新的问题来了，如果注解是接口，那么其何时实例化，怎么实例化？

我们是通过 AnnotionTest.class.getDeclaredAnnotations(Test2.class); 来获取到注解的实例的，那么看这个方法

![在这里插入图片描述](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408181243528.png)

发现返回的实例名称 是$Proxy1, 很明显是一个代理对象。

里面还有一个叫AnnotationInvocationHandler的类，是不是很眼熟？

这个就是注解的代理逻辑封装

```java
class AnnotationInvocationHandler implements InvocationHandler, Serializable {
    private static final long serialVersionUID = 6182022883658399397L;
	//保存了当前注解的类型
    private final Class<? extends Annotation> type;
	//保存了注解的成员属性的名称和值的映射，注解成员属性的名称实际上就对应着接口中抽象方法的名称
    private final Map<String, Object> memberValues;
    private transient volatile Method[] memberMethods = null;

    AnnotationInvocationHandler(Class<? extends Annotation> var1, Map<String, Object> var2) {
        Class[] var3 = var1.getInterfaces();
        if (var1.isAnnotation() && var3.length == 1 && var3[0] == Annotation.class) {
            this.type = var1;
            this.memberValues = var2;
        } else {
            throw new AnnotationFormatError("Attempt to create proxy for a non-annotation type.");
        }
    }

    public Object invoke(Object var1, Method var2, Object[] var3) {
		//获取当前执行的方法名称
        String var4 = var2.getName();
        Class[] var5 = var2.getParameterTypes();
        if (var4.equals("equals") && var5.length == 1 && var5[0] == Object.class) {
            return this.equalsImpl(var3[0]);
        } else if (var5.length != 0) {
            throw new AssertionError("Too many parameters for an annotation method");
        } else {
            byte var7 = -1;
            switch(var4.hashCode()) {
            case -1776922004:
                if (var4.equals("toString")) {
                    var7 = 0;
                }
                break;
            case 147696667:
                if (var4.equals("hashCode")) {
                    var7 = 1;
                }
                break;
            case 1444986633:
                if (var4.equals("annotationType")) {
                    var7 = 2;
                }
            }
            switch(var7) {
            case 0:
                return this.toStringImpl();
            case 1:
                return this.hashCodeImpl();
            case 2:
                return this.type;
            default:
			    //利用方法名称从memberValues获取成员属性的赋值
                Object var6 = this.memberValues.get(var4);
                if (var6 == null) {
                    throw new IncompleteAnnotationException(this.type, var4);
                } else if (var6 instanceof ExceptionProxy) {
                    throw ((ExceptionProxy)var6).generateException();
                } else {
					//这一步就是注解成员属性返回值获取的实际逻辑
					//需要判断是否数据，如果是数据需要克隆一个数组
					//不是数组直接返回
                    if (var6.getClass().isArray() && Array.getLength(var6) != 0) {
                        var6 = this.cloneArray(var6);
                    }
                    return var6;
                }
            }
        }
    }
//忽略其他方法	
```

jdk的动态代理，需要一个Proxy类（jdk提供的用于生成对象的类），一个实现了InvocationHandler接口的类（用于封装代理逻辑的类）

```java
static class AnnotationInvocationHandler implements InvocationHandler{
  
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   //处理注解的解析
    }
     
  }
```

因此 AnnotationInvocationHandler里面就封装了 注解的代理逻辑。

使用的时候

使用Proxy.newProxyInstance（）

```java
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException{
    //
}
```

newProxyInstance，方法有三个参数

- loader: 用哪个类加载器去加载代理对象
- interfaces:动态代理类需要实现的接口
- h:动态代理方法在执行时，会调用h里面的invoke方法去执行

**那么注解实例化之后，值从哪里取的呢？ 或者说，一开始传给注解的参数，存储到了哪？**

分析流程

- java.lang.Class#getDeclaredAnnotation 第一步 获取注解
- java.lang.Class#createAnnotationData 第二步 创建注解实例
- sun.reflect.annotation.AnnotationParser#parseAnnotations 第三步 解析注解

这一步有个关键点

方法getRawAnnotations() 获取原始批注 是native方法

还有一个方法getConstantPool() 获取常量池 也是native方法

```java
private AnnotationData createAnnotationData(int classRedefinedCount) {
        Map<Class<? extends Annotation>, Annotation> declaredAnnotations =
            AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
        Class<?> superClass = getSuperclass();
        Map<Class<? extends Annotation>, Annotation> annotations = null;
        if (superClass != null) {
            Map<Class<? extends Annotation>, Annotation> superAnnotations =
                superClass.annotationData().annotations;
            for (Map.Entry<Class<? extends Annotation>, Annotation> e : superAnnotations.entrySet()) {
                Class<? extends Annotation> annotationClass = e.getKey();
                if (AnnotationType.getInstance(annotationClass).isInherited()) {
                    if (annotations == null) { // lazy construction
                        annotations = new LinkedHashMap<>((Math.max(
                                declaredAnnotations.size(),
                                Math.min(12, declaredAnnotations.size() + superAnnotations.size())
                            ) * 4 + 2) / 3
                        );
                    }
                    annotations.put(annotationClass, e.getValue());
                }
            }
        }
        if (annotations == null) {
            // no inherited annotations -> share the Map with declaredAnnotations
            annotations = declaredAnnotations;
        } else {
            // at least one inherited annotation -> declared may override inherited
            annotations.putAll(declaredAnnotations);
        }
        return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
    }
```

然后经过sun.reflect.annotation.AnnotationParser#parseAnnotation2这个类的加工转换

到要创建实例的时候

sun.reflect.annotation.AnnotationParser#annotationForMap

该方法返回的入参， 里面有整个Test2这个注解类的信息 ，这一步就获取了注解里面的值，存储在memberDefaults 这个hashmap里面

![在这里插入图片描述](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408181255314.png)



# Spring注解

## @bean 和 @component

### 两个注解的作用

@Component： 作用于类上，告知Spring，为这个类创建Bean

@Bean：主要作用于方法上，告知Spring，这个方法会返回一个对象，且要注册在Spring的上下文中。通常方法体中包含产生Bean的逻辑。 相当于 xml文件的中<bean>标签

```java
1、org.springframework.stereotype.Component 
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
      
}
 
2、org.springframework.context.annotation.Bean
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {
    
}
```

### **区别**

@Component ：作用于类上，通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（@Controller、@Service、@Repository ）

@Bean： 作用于方法或注解上，通常这个方法中定义产生这个Bean的逻辑

```java
3、@Bean注解和 <bean> 标签
<bean id="user" class="xxx.User">
    <property name="id" value="11" ></property>
</bean>
 
@Configuration
public class UserConfig {
	@Bean
	public User getUser() {
		User user =new User();
		user.setId(11);
		return user;
	}
}
```

**联系**

作用都是一样的，都是注册bean到Spring容器中。

引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现。如下：

```java
@Bean
public OneService getService(status) {
    case (status)  {
        when 1:
                return new serviceImpl1();
        when 2:
                return new serviceImpl2();
        when 3:
                return new serviceImpl3();
    }
}
```

以上这个例子是无法用Component以及其具体实现注解（Controller、Service、Repository）来实现的

## @Component注解实现原理

用来标记的类是一个“组件”或者说是一个Bean，Spring会自动扫描标记`@Component`注解的类作为一个Spring Bean对象

```java
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.stereotype;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Indicates that an annotated class is a "component".
 * Such classes are considered as candidates for auto-detection
 * when using annotation-based configuration and classpath scanning.
 *
 * <p>Other class-level annotations may be considered as identifying
 * a component as well, typically a special kind of component:
 * e.g. the {@link Repository @Repository} annotation or AspectJ's
 * {@link org.aspectj.lang.annotation.Aspect @Aspect} annotation.
 *
 * @author Mark Fisher
 * @since 2.5
 * @see Repository
 * @see Service
 * @see Controller
 * @see org.springframework.context.annotation.ClassPathBeanDefinitionScanner
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 */
	String value() default "";

}

```

**属性说明：**

- value: 自定义当前组件或者说bean的名称，可以不配置， 不配置的话默认为组件的首字母小写的类名。

**元注解说明：**

- 该注解只能使用在类，接口、枚举、其他注解上
- 该注解的生命周期是运行时JVM
- @Indexed元注解在spring 5.0引入，用于项目编译打包时，会在自动生成META-INF/spring.components文件，简历索引，从而提高组件扫描效率，减少应用启动时间

-----

**原理**

SpringBoot应用启动会注册`ConfigurationClassPostProcessor`这个Bean，它实现了`BeanDefinitionRegistryPostProcessor`接口，而这个接口是Spring提供的一个扩展点，可以往BeanDefinition Registry中添加BeanDefintion。所以，只要能够扫描到`@Component`注解的类，并且把它注册到BeanDefinition Registry中即可

关键方法`ConfigurationClassPostProcessor`的`postProcessBeanDefinitionRegistry`，查找`@Component`的类，并进行注册

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408181409448.webp)

查看`@Component`注解的源码，从中可以看到一个关键的类`ClassPathBeanDefinitionScanner`

我们直接跳到是如何查找`@Component`的类的，核心方法就是`ClassPathBeanDefinitionScanner#doScan`

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
		Assert.notEmpty(basePackages, "At least one base package must be specified");
		Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
        // 遍历多个扫描目录，如本例中的com.alvinlkk
		for (String basePackage : basePackages) {
            // 核心方法查找所有符合条件的BeanDefinition, 该方法后面重点关注
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
			// 遍历找到的BeanDefinition
            for (BeanDefinition candidate : candidates) {
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
				if (candidate instanceof AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
				}
				if (candidate instanceof AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
				}
                // 验证BeanDefinition
				if (checkCandidate(beanName, candidate)) {
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder =
							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
					beanDefinitions.add(definitionHolder);
                    // 注册BeanDefinition到registry中
					registerBeanDefinition(definitionHolder, this.registry);
				}
			}
		}
		return beanDefinitions;
	}
```

重点关注`ClassPathBeanDefinitionScanner#findCandidateComponents`方法，找出候选的Bean Component

```java
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
		// 判断组件是否加了索引，打包后默认会有索引，用于加快扫描
        if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
			return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
		}
       // 重点查看else逻辑
		else {
			return scanCandidateComponents(basePackage);
		}
	}
```

```java
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
		Set<BeanDefinition> candidates = new LinkedHashSet<>();
		try {
            // 解析出需要扫描的路径，本例是classpath*:com/alvinlkk/**/*.class
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + '/' + this.resourcePattern;
			// 根据扫描路径找到所有的Resource
            Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
			boolean traceEnabled = logger.isTraceEnabled();
			boolean debugEnabled = logger.isDebugEnabled();
            // 遍历扫描路径
			for (Resource resource : resources) {
				if (traceEnabled) {
					logger.trace("Scanning " + resource);
				}
				try {
                    // 解析出扫描到类的元数据信息，里面包含了注解信息
					MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
					// 关键方法，判断是否候选组件
                    if (isCandidateComponent(metadataReader)) {
						ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
						sbd.setSource(resource);
						if (isCandidateComponent(sbd)) {
							if (debugEnabled) {
								logger.debug("Identified candidate component class: " + resource);
							}
							candidates.add(sbd);
						}
						else {
							if (debugEnabled) {
								logger.debug("Ignored because not a concrete top-level class: " + resource);
							}
						}
					}
					else {
						if (traceEnabled) {
							logger.trace("Ignored because not matching any filter: " + resource);
						}
					}
				}
				catch (FileNotFoundException ex) {
					if (traceEnabled) {
						logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());
					}
				}
				catch (Throwable ex) {
					throw new BeanDefinitionStoreException(
							"Failed to read candidate component class: " + resource, ex);
				}
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
		}
		return candidates;
	}
```

```java
// 判断是否候选的Bean Component
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
		// exclude过滤器,在exclude过滤其中的，会直接排除掉，返回false
        for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, getMetadataReaderFactory())) {
				return false;
			}
		}
       // include过滤器， 这里会看到有AnnotationTypeFilter,注解类型过滤器
		for (TypeFilter tf : this.includeFilters) {
            // 调用AnnotationTypeFilter的match方法，来判断是否满足条件
			if (tf.match(metadataReader, getMetadataReaderFactory())) {
                // 下面在进行Condition的判断，就是类上的@Conditional，这里不是重点
				return isConditionMatch(metadataReader);
			}
		}
		return false;
	}
```

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408181415891.webp)

而这个AnnotationTypeFilter默认是在构造函数中注册进去的

```java
public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware {

	static final String DEFAULT_RESOURCE_PATTERN = "**/*.class";


	protected final Log logger = LogFactory.getLog(getClass());

	private String resourcePattern = DEFAULT_RESOURCE_PATTERN;

	private final List<TypeFilter> includeFilters = new ArrayList<>();

	private final List<TypeFilter> excludeFilters = new ArrayList<>();

	@Nullable
	private Environment environment;

	@Nullable
	private ConditionEvaluator conditionEvaluator;

	@Nullable
	private ResourcePatternResolver resourcePatternResolver;

	@Nullable
	private MetadataReaderFactory metadataReaderFactory;

	@Nullable
	private CandidateComponentsIndex componentsIndex;

protected void registerDefaultFilters() {
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
		ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
		try {
			this.includeFilters.add(new AnnotationTypeFilter(
					((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
			logger.trace("JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning");
		}
		catch (ClassNotFoundException ex) {
			// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.
		}
		try {
			this.includeFilters.add(new AnnotationTypeFilter(
					((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));
			logger.trace("JSR-330 'javax.inject.Named' annotation found and supported for component scanning");
		}
		catch (ClassNotFoundException ex) {
			// JSR-330 API not available - simply skip.
		}
	}
}
```

**小结**

@Component到Spring bean容器管理过程如下：

- 初始化时设置了Component类型过滤器；
- 根据指定扫描包扫描.class文件，生成Resource对象；
- 解析.class文件并注解归类，生成MetadataReader对象；
- 使用第一步的注解过滤器过滤出有@Component类；
- 生成BeanDefinition对象；
- 把BeanDefinition注册到Spring容器

> @Component是任何Spring管理的组件的通用原型。@Repository、@Service和@Controller是派生自@Component
>
> ```java
> @Target({ElementType.TYPE})
> @Retention(RetentionPolicy.RUNTIME)
> @Documented
> // @Service 派生自@Component
> @Component
> public @interface Service {
> 
>    /**
>     * The value may indicate a suggestion for a logical component name,
>     * to be turned into a Spring bean in case of an autodetected component.
>     * @return the suggested component name, if any (or empty String otherwise)
>     */
>    @AliasFor(annotation = Component.class)
>    String value() default "";
> 
> }
> ```

## @Bean注解原理详解

**@Bean注解的作用**

这是一个我们很常用的注解，作用是指示一个方法生成一个由Spring管理的Bean

![在这里插入图片描述](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202408182046650.png)

本篇就已这个例子进行分析`@Bean`注解的实现方式

在创建好 BeanFactory 后会调用所有的 BeanFactoryPostProcessor 处理器对其进行后置处理。`@Bean` 注解就是在这个过程被解析的，解析过程大致就是遍历所有的 BeanDefinition，如果其内部包含 `@Bean` 标注的注解，则会将该方法解析出一个 BeanDefinition 对象并注册。当然，除了 `@Bean` 注解外，例如 `@ComponentScan`、`@Import`、`@ImportResource`、`@PropertySource` 注解都是在该过程中进行解析的。那么接下来将分析整个的解析过程，入口在 `ConfigurationClassPostProcessor` 这个处理器中

### 概览

主要涉及以下几个类

- `org.springframework.context.annotation.ConfigurationClassPostProcessor`，处理 Spring 应用上下文中的**配置类**，解析 `@Bean` 等注解，并进行 CGLIB 提升

- `org.springframework.context.annotation.ConfigurationClass`，根据前面提到的**配置类**解析出来的对象，包含各种注解的信息，例如 `@Bean`、`@Import`

- `org.springframework.context.annotation.ConfigurationClassParser`，解析**配置类**，生成 ConfigurationClass 对象并保存

- `org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader`，**配置类**中 BeanDefinition 的读取器，根据 ConfigurationClass 解析出 BeanDefinition 并注册

**ConfigurationClassParser--->ConfigurationClass--->ConfigurationClassBeanDefinitionReader--->BeanDefinition **

> **配置类**：带有 `@Configuration` 注解的类，如果这个类带有 `@Component` | `@ComponentScan` | `@Import` | `@ImportSource` 注解，或者内部存在 `@Bean` 的方法都算**配置类**

### BeanFactoryPostProcessor

```java
@FunctionalInterface
public interface BeanFactoryPostProcessor {
	/**
	 * 在标准初始化之后修改应用程序上下文的内部 bean 工厂。所有 bean 定义都将被加载，但还没有 bean 被实例化。
	 * 这允许覆盖或添加属性，甚至是急切初始化的 bean。
	 */
	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
```

Spring IoC容器允许BeanFactoryPostProcessor在容器实例化任何bean之前读取bean的定义(配置元数据)，并可以修改它或者实现bean动态代理等。同时可以定义多个BeanFactoryPostProcessor，通过设置’order’属性来确定各个BeanFactoryPostProcessor执行顺序。

与BeanFactoryPostProcessor相关的两个很重要的类

- BeanDefinitionRegistryPostProcessor 这个接口是对BeanFactoryPostProcessor的进一步扩展，其中的postProcessBeanDefinitionRegistry方法可以对BeanDefinition做更多的定义
- ConfigurationClassPostProcessor 这个类实现了BeanDefinitionRegistryPostProcessor，具体的实现了对Bean的扫描和BeanDefinition的修改

-----

@Bean注解是在的org.springframework.context.support.AbstractApplicationContext#refresh方法中被加载的，具体是在org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors方法中被扫描到的

这个方法主要作用就是根据反射机制从BeanDefinitionRegistry(bean定义注册中心)中找到所有实现了BeanFactoryPostProcessor接口bean，并调用其postProcessBeanFactory（）接口方法， 其实就是对Bean定义的增强/修改，同时也是一个非常有效的扩展点。跟进这个方法

```java
public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
	//一开始进来的时候，beanFactoryPostProcessors中有三个BeanFactoryPostProcessor的实现，这三个与本篇关系不大就不详细说了，感兴趣的同学可以自行断点查看
	// Invoke BeanDefinitionRegistryPostProcessors first, if any.
	// 如果有的话，首先执行 BeanDefinitionRegistryPostProcessors
	Set<String> processedBeans = new HashSet<>();

	if (beanFactory instanceof BeanDefinitionRegistry) {
		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
		List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
		List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

		for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
			//如果入参的BeanFactoryPostProcessor 中有实现自BeanDefinitionRegistryPostProcessor的
			// 那就先执行它的postProcessBeanDefinitionRegistry  然后对beanFactoryPostProcessors中的进行分组
			if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
				BeanDefinitionRegistryPostProcessor registryProcessor =
						(BeanDefinitionRegistryPostProcessor) postProcessor;
				//
				registryProcessor.postProcessBeanDefinitionRegistry(registry);
				registryProcessors.add(registryProcessor);
			}
			else {
				regularPostProcessors.add(postProcessor);
			}
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		// Separate between BeanDefinitionRegistryPostProcessors that implement
		// PriorityOrdered, Ordered, and the rest.
		List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

		// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
		// 首先，调用实现 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor
		
		// 这里是从beanFactory中查找BeanDefinitionRegistryPostProcessor的Bean
		// 这里获取的结果是：org.springframework.context.annotation.internalConfigurationAnnotationProcessor   能获取到这个的原因在下面写
		// 对应的类是：org.springframework.context.annotation.ConfigurationClassPostProcessor  这个类也就是本篇的重点类
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				// ConfigurationClassPostProcessor实现了PriorityOrdered  所以优先处理  此处先实例化然后用于后续执行
				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
				// 记录已实例化的  其实就是记录一下已经处理过的  后续需要排除
				processedBeans.add(ppName);
			}
		}
		sortPostProcessors(currentRegistryProcessors, beanFactory);
		registryProcessors.addAll(currentRegistryProcessors);
		// 然后进入这个方法处理  这一步就是具体的ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry执行逻辑了
		// 下面会详细分析  这里打个标记！！！！！！  方便搜索
		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
		currentRegistryProcessors.clear();

		// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
		// 接下来，调用实现 Ordered 的 BeanDefinitionRegistryPostProcessors
		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
		for (String ppName : postProcessorNames) {
			if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
				processedBeans.add(ppName);
			}
		}
		sortPostProcessors(currentRegistryProcessors, beanFactory);
		registryProcessors.addAll(currentRegistryProcessors);
		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
		currentRegistryProcessors.clear();

		// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
		// 最后，循环调用所有其他BeanDefinitionRegistryPostProcessors直到没有未处理的
		boolean reiterate = true;
		while (reiterate) {
			reiterate = false;
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
					reiterate = true;
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();
		}
		// 到这里 我们可以看到BeanDefinitionRegistryPostProcessor处理流程是先处理PriorityOrdered的
		// 再处理Ordered的, 最后在循环处理所有的
		// 目的是先执行内置必要的BeanDefinitionRegistryPostProcessor，在处理过程中可能会有添加新的BeanDefinitionRegistryPostProcessor实现，
		// 然后重新获取，排除已执行的然后根据Ordered排序再执行实现了Ordered的
		// 上面两个都执行完成之后，不可避免的还会有其他的BeanDefinitionRegistryPostProcessor实现
		// 最后就再把剩余的BeanDefinitionRegistryPostProcessor实现再循环处理
		// 循环的原因也是因为在执行的过程中可能会有新的BeanDefinitionRegistryPostProcessor实现添加，所以循环执行所有的
		
		// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
		// 到这里再调用到目前为止处理的所有处理器的 postProcessBeanFactory 回调  也就是本方法入参beanFactoryPostProcessors进来的那几个
		// 其实就是BeanFactoryPostProcessor的postProcessBeanFactory
		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
	}

	else {
		// Invoke factory processors registered with the context instance.
		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
	}

	// Do not initialize FactoryBeans here: We need to leave all regular beans
	// uninitialized to let the bean factory post-processors apply to them!
	// 不要在此处初始化 FactoryBeans：我们需要让所有常规 bean 保持未初始化状态，以便 bean 工厂后处理器应用到它们！

	// 从工厂中查找BeanFactoryPostProcessor的实现
	String[] postProcessorNames =
			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

	// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
	// Ordered, and the rest.
	// 将实现 PriorityOrdered、Ordered、其余部分 的 BeanFactoryPostProcessor 分组
	List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
	List<String> orderedPostProcessorNames = new ArrayList<>();
	List<String> nonOrderedPostProcessorNames = new ArrayList<>();
	for (String ppName : postProcessorNames) {
		if (processedBeans.contains(ppName)) {
			// 跳过在上面已经执行过的，其实在我们的例子中这里跳过的就是上面执行过的ConfigurationClassPostProcessor
			// skip - already processed in first phase above
		}
		else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
		}
		else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
			orderedPostProcessorNames.add(ppName);
		}
		else {
			nonOrderedPostProcessorNames.add(ppName);
		}
	}

	// 然后再根据分组结果，依次执行BeanFactoryPostProcessor的处理流程

	// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
	// 首先，调用实现 PriorityOrdered 的 BeanFactoryPostProcessor
	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

	// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
	// 接下来，调用实现 Ordered 的 BeanFactoryPostProcessors
	List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
	for (String postProcessorName : orderedPostProcessorNames) {
		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
	}
	sortPostProcessors(orderedPostProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

	// Finally, invoke all other BeanFactoryPostProcessors.
	// 最后，调用所有其他 BeanFactoryPostProcessor
	List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
	for (String postProcessorName : nonOrderedPostProcessorNames) {
		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
	}
	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

	// Clear cached merged bean definitions since the post-processors might have
	// modified the original metadata, e.g. replacing placeholders in values...
	beanFactory.clearMetadataCache();
}
```

上面这段源码贴出来，并写了一些注释，主要是说明了这个方法的大体执行逻辑，我们本篇分析的是@Bean的原理，所以我们重点看其中的：invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);这一步(源码中注释标记“！！！！！！”的那一步)，也就是实现了PriorityOrdered的BeanDefinitionRegistryPostProcessor处理

> 在进行重点源码分析前先说一下为什么在beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);这一步能获取到org.springframework.context.annotation.internalConfigurationAnnotationProcessor，原因是SpringBoot在启动时候，org.springframework.boot.SpringApplication#run(java.lang.String...)方法中有一步：context = createApplicationContext();，其中创建了容器：org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext，在实例化这个容器的时候，他的无参构造会执行到：org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)这个方法，这个里面给Spring工厂中注册了org.springframework.context.annotation.internalConfigurationAnnotationProcessor，这一步大家可以找到地方自行断点查看，不是本篇的重点就不详细说了

进入`invokeBeanDefinitionRegistryPostProcessors`方法

```java
private static void invokeBeanDefinitionRegistryPostProcessors(
		Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {
	// 根据我们上面跟进的内容，这里的postProcessors只有一个值：ConfigurationClassPostProcessor
	for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
		postProcessor.postProcessBeanDefinitionRegistry(registry);
	}
}
```

所以我们跟进到`org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry`**看**

```java
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
	int registryId = System.identityHashCode(registry);
	if (this.registriesPostProcessed.contains(registryId)) {
		throw new IllegalStateException(
				"postProcessBeanDefinitionRegistry already called on this post-processor against " + registry);
	}
	if (this.factoriesPostProcessed.contains(registryId)) {
		throw new IllegalStateException(
				"postProcessBeanFactory already called on this post-processor against " + registry);
	}
	this.registriesPostProcessed.add(registryId);

	processConfigBeanDefinitions(registry);
}
```

然后继续跟进到：`processConfigBeanDefinitions(registry);`

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
	List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
	// 获取工厂中的BeanDefinitionNames
	String[] candidateNames = registry.getBeanDefinitionNames();

	//循环所有的BeanNames 找出候选配置类
	for (String beanName : candidateNames) {
		BeanDefinition beanDef = registry.getBeanDefinition(beanName);
		if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
			}
		}
		else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
			// 在本例中这里其实就是SpringBoot的启动类   因为@SpringBootApplication注解是个组合注解，其中包含@Configuration注解
			configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
		}
	}

	// Return immediately if no @Configuration classes were found
	// 如果没有找到 @Configuration 类，则立即返回
	if (configCandidates.isEmpty()) {
		return;
	}

	// Sort by previously determined @Order value, if applicable
	// 按@Order 值排序（如果合适）
	configCandidates.sort((bd1, bd2) -> {
		int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
		int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
		return Integer.compare(i1, i2);
	});

	// Detect any custom bean name generation strategy supplied through the enclosing application context
	// 检测通过应用程序上下文提供的任何自定义 bean 名称生成策略  默认没有
	SingletonBeanRegistry sbr = null;
	if (registry instanceof SingletonBeanRegistry) {
		sbr = (SingletonBeanRegistry) registry;
		if (!this.localBeanNameGeneratorSet) {
			BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(
					AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
			if (generator != null) {
				this.componentScanBeanNameGenerator = generator;
				this.importBeanNameGenerator = generator;
			}
		}
	}

	if (this.environment == null) {
		this.environment = new StandardEnvironment();
	}

	// Parse each @Configuration class
	// 解析每个 @Configuration 类
	ConfigurationClassParser parser = new ConfigurationClassParser(
			this.metadataReaderFactory, this.problemReporter, this.environment,
			this.resourceLoader, this.componentScanBeanNameGenerator, registry);

	Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
	Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
	do {
		// 解析的重点方法  
		// 这里面会进行包扫描并处理@Bean等注解的解析，并封装成ConfigurationClass，设置对应的标记BeanMethod
		// 下面会展开分析这个方法  
		parser.parse(candidates);
		parser.validate();

		Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
		configClasses.removeAll(alreadyParsed);

		// Read the model and create bean definitions based on its content
		if (this.reader == null) {
			this.reader = new ConfigurationClassBeanDefinitionReader(
					registry, this.sourceExtractor, this.resourceLoader, this.environment,
					this.importBeanNameGenerator, parser.getImportRegistry());
		}
		// 到这里已经获取到所有的配置类并封装成ConfigurationClass
		// 通过ConfigurationClass的BeanMethod解析@Bean注解的相关内容并构造出要注册的对象的BeanDefinition
		// 最后注册到工厂中去
		// 这一步下面也会展开解析
		this.reader.loadBeanDefinitions(configClasses);
		alreadyParsed.addAll(configClasses);

		candidates.clear();
		if (registry.getBeanDefinitionCount() > candidateNames.length) {
			String[] newCandidateNames = registry.getBeanDefinitionNames();
			Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));
			Set<String> alreadyParsedClasses = new HashSet<>();
			for (ConfigurationClass configurationClass : alreadyParsed) {
				alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
			}
			for (String candidateName : newCandidateNames) {
				if (!oldCandidateNames.contains(candidateName)) {
					BeanDefinition bd = registry.getBeanDefinition(candidateName);
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
							!alreadyParsedClasses.contains(bd.getBeanClassName())) {
						candidates.add(new BeanDefinitionHolder(bd, candidateName));
					}
				}
			}
			candidateNames = newCandidateNames;
		}
	}
	while (!candidates.isEmpty());

	// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
	if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
		sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
	}

	if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
		// Clear cache in externally provided MetadataReaderFactory; this is a no-op
		// for a shared cache since it'll be cleared by the ApplicationContext.
		((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
	}
}
```

这个方法大家看下注释，我们重点看下面这两个方法：

parser.parse(candidates);

this.reader.loadBeanDefinitions(configClasses);

这两个方法是核心，依次分开解析：

### parser.parse(candidates)解析

进入源码`org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set<org.springframework.beans.factory.config.BeanDefinitionHolder>)`跟进

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
	for (BeanDefinitionHolder holder : configCandidates) {
		BeanDefinition bd = holder.getBeanDefinition();
		try {
			if (bd instanceof AnnotatedBeanDefinition) {
				// 注解类型的BeanDefinition 我们的SpringBoot启动类会进入这个  所以进入这个parse方法
				parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
			}
			else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
				parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
			}
			else {
				parse(bd.getBeanClassName(), holder.getBeanName());
			}
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(
					"Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
		}
	}

	this.deferredImportSelectorHandler.process();
}
```

跟进`parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())`;来到：`org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass`

```java
protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
	if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
		return;
	}
	// 这里是第一次加载 所以肯定是空的
	ConfigurationClass existingClass = this.configurationClasses.get(configClass);
	if (existingClass != null) {
		if (configClass.isImported()) {
			if (existingClass.isImported()) {
				existingClass.mergeImportedBy(configClass);
			}
			// Otherwise ignore new imported config class; existing non-imported class overrides it.
			return;
		}
		else {
			// Explicit bean definition found, probably replacing an import.
			// Let's remove the old one and go with the new one.
			this.configurationClasses.remove(configClass);
			this.knownSuperclasses.values().removeIf(configClass::equals);
		}
	}

	// Recursively process the configuration class and its superclass hierarchy.
	// 递归处理配置类及其超类层次结构
	// 这一步是做校验并封装成SourceClass 
	SourceClass sourceClass = asSourceClass(configClass, filter);
	do {
		// 循环递归处理 
		sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
	}
	while (sourceClass != null);

	// 处理完成后加入缓存
	this.configurationClasses.put(configClass, configClass);
}
```

详细看：`doProcessConfigurationClass(configClass, sourceClass, filter)`;：`org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass`

```java
protected final SourceClass doProcessConfigurationClass(
			ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
			throws IOException {

	// 是不是有Component注解  启动类的@SpringBootApplication注解中有Component注解 所以会进入if
	if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
		// Recursively process any member (nested) classes first
		// 首先递归处理任何成员（嵌套）类   这个类没有嵌套  所以略过
		processMemberClasses(configClass, sourceClass, filter);
	}

	// Process any @PropertySource annotations
	// 处理任何 @PropertySource 注释   没有这个注释所以跳过
	for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
			sourceClass.getMetadata(), PropertySources.class,
			org.springframework.context.annotation.PropertySource.class)) {
		if (this.environment instanceof ConfigurableEnvironment) {
			processPropertySource(propertySource);
		}
		else {
			logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
					"]. Reason: Environment must implement ConfigurableEnvironment");
		}
	}

	// Process any @ComponentScan annotations
	// 处理任何@ComponentScan注释      @SpringBootApplication注解中有@ComponentScan注解 所以会获取到一个AnnotationAttributes
	Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
			sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
	if (!componentScans.isEmpty() &&
			!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
		for (AnnotationAttributes componentScan : componentScans) {
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			// 配置类使用 @ComponentScan 注解 -> 立即执行扫描
			// 这一步是重点  下面会展开解析
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
			// Check the set of scanned definitions for any further config classes and parse recursively if needed
			// 检查扫描出来的Bean定义，如果需要并循环解析更深层级的配置
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
				if (bdCand == null) {
					bdCand = holder.getBeanDefinition();
				}
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
					// 再次解析
					parse(bdCand.getBeanClassName(), holder.getBeanName());
				}
			}
		}
	}

	// Process any @Import annotations
	// 处理任何 @Import 注释
	processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

	// Process any @ImportResource annotations
	// 处理任何 @ImportResource 注释
	AnnotationAttributes importResource =
			AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
	if (importResource != null) {
		String[] resources = importResource.getStringArray("locations");
		Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
		for (String resource : resources) {
			String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
			configClass.addImportedResource(resolvedResource, readerClass);
		}
	}

	// Process individual @Bean methods
	// 处理单个 @Bean 方法
	Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
	// 获取到所有的@Bean方法的元数据
	for (MethodMetadata methodMetadata : beanMethods) {
		// 封装成BeanMethod添加到ConfigurationClass
		configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
	}

	// Process default methods on interfaces
	// 处理接口上的默认方法
	processInterfaces(configClass, sourceClass);

	// Process superclass, if any
	if (sourceClass.getMetadata().hasSuperClass()) {
		String superclass = sourceClass.getMetadata().getSuperClassName();
		if (superclass != null && !superclass.startsWith("java") &&
				!this.knownSuperclasses.containsKey(superclass)) {
			this.knownSuperclasses.put(superclass, configClass);
			// Superclass found, return its annotation metadata and recurse
			return sourceClass.getSuperClass();
		}
	}

	// No superclass -> processing is complete
	return null;
}
```

上面这段代码步骤是：

先处理@Component的嵌套类
再处理@PropertySource
再处理@ComponentScan，这一步是包扫描的重点过程，扫描到包路径下的所有符合条件的Bean并封装成BeanDefinitionHolder返回
再处理@Import
再处理@ImportResource
再处理@Bean，将扫描出来的所有@Bean元数据记录下来
再处理接口上的@Bean
如果有父类处理父类
我们重点来看@ComponentScan的这一步，所以跟进`this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())`;

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
	// 创建BeanDefinition的扫描器
	ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
			componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

	//获取@ComponentScan注解的nameGenerator Class
	Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
	boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
	scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
			BeanUtils.instantiateClass(generatorClass));

	//获取@ComponentScan注解的scopedProxy
	ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
	if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
		scanner.setScopedProxyMode(scopedProxyMode);
	}
	else {
		Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
		scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
	}

	//获取@ComponentScan注解的resourcePattern
	scanner.setResourcePattern(componentScan.getString("resourcePattern"));

	//获取@ComponentScan注解的includeFilters
	for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
		for (TypeFilter typeFilter : typeFiltersFor(filter)) {
			scanner.addIncludeFilter(typeFilter);
		}
	}
	//获取@ComponentScan注解的excludeFilters
	for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
		for (TypeFilter typeFilter : typeFiltersFor(filter)) {
			scanner.addExcludeFilter(typeFilter);
		}
	}

	//获取@ComponentScan注解的lazyInit
	boolean lazyInit = componentScan.getBoolean("lazyInit");
	if (lazyInit) {
		scanner.getBeanDefinitionDefaults().setLazyInit(true);
	}

	Set<String> basePackages = new LinkedHashSet<>();
	// 获取@ComponentScan注解的basePackages  
	// 获取配置的扫描包路径，这个大家应该用过，有时候会在启动类上配置这个用来自定义包扫描路径
	// 在我们的例子中是没有配置的  所有这个为空
	String[] basePackagesArray = componentScan.getStringArray("basePackages");
	for (String pkg : basePackagesArray) {
		String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
				ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
		Collections.addAll(basePackages, tokenized);
	}
	for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
		basePackages.add(ClassUtils.getPackageName(clazz));
	}
	// 如果没有配置basePackages   那么取启动类所在的包路径！！！
	if (basePackages.isEmpty()) {
		basePackages.add(ClassUtils.getPackageName(declaringClass));
	}

	scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
		@Override
		protected boolean matchClassName(String className) {
			return declaringClass.equals(className);
		}
	});
	// 根据获取到的包路径进行扫描  在我们的例子中这里就是启动类所在的包com.ygz.test1
	return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

这段代码主要是解析`@ComponentScan`注解的元数据，并获取到要扫描的包路径，代码不难就不细说了大家看注释就行，我们接着跟进到`scanner.doScan(StringUtils.toStringArray(basePackages));`

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
	Assert.notEmpty(basePackages, "At least one base package must be specified");
	Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
	// 循环要扫描的包路径  我们的例子中只有一个
	for (String basePackage : basePackages) {
		// 通过包路径进行扫描 把所有扫描出来的Bean封装成BeanDefinition返回出来
		// 这一步其实就是spring的Bean扫描流程了，本篇主要是@Bean的解析过程，这里就不深入跟进了，里面内容较多  大家可以自行debug查看
		Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
		// 这个循环主要是把获取到的BeanDefinition做进一步的处理
		// 设置scope、设置其他的一些属性、检查是否需要代理需要的话创建代理等  最终把这个BeanDefinition 注册到工厂中
		for (BeanDefinition candidate : candidates) {
			ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
			candidate.setScope(scopeMetadata.getScopeName());
			String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
			if (candidate instanceof AbstractBeanDefinition) {
				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
			}
			if (candidate instanceof AnnotatedBeanDefinition) {
				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
			}
			if (checkCandidate(beanName, candidate)) {
				BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
				definitionHolder =
						AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
				beanDefinitions.add(definitionHolder);
				registerBeanDefinition(definitionHolder, this.registry);
			}
		}
	}
	return beanDefinitions;
}
```

到这里就已经扫描到所有的Bean的BeanDefinition 并注册到工厂了，返回所有的BeanDefinition ，然后我们回到`org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass`方法的解析@ComponentScan代码位置，通过`Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());`这一步拿到了扫描出来的所有BeanDefinition ，然后循环每一个并检查是不是配置类，然后如果是配置类，那么再次调用解析方法解析配置类，这里其实类似递归过程。下面把这部分代码再贴出来一下
```java
// 这一段是org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法解析@ComponentScan注解的部分代码


// The config class is annotated with @ComponentScan -> perform the scan immediately
// 通过@ComponentScan扫描出所有的Bean并获取到BeanDefinitionHolder
Set<BeanDefinitionHolder> scannedBeanDefinitions =
		this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
// Check the set of scanned definitions for any further config classes and parse recursively if needed
// 循环判断是不是配置类，如果是配置类那么继续递归解析
for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
	BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
	if (bdCand == null) {
		bdCand = holder.getBeanDefinition();
	}
	// 在我们的例子中，TestConfig类标记有@Configuration注解，所以是配置类，会进入这个if
	// 然后会在parse方法中继续递归的去解析TestConfig类，在解析到@Bean注解的时候就会把TestConfig类的myTest()方法扫描出来
	// 这里这个递归大家要能理解，这里第一次parse是通过SpringBoot的启动类扫描所有的Bean
	// 获取到所有的BeanDefinition之后循环每一个，查看是不是配置类，如果是配置类那么递归调用parse方法
	// 比如在我们的例子中TestConfig被启动类扫描到之后，会在这里再次被parse，然后再次进入本方法(就是doProcessConfigurationClass)
	// 当再次进入之后，TestConfig中有方法myTest()标记了@Bean注解  那么就会被@Bean注解处理流程处理 这个处理我们下面会跟进
	// 这里大家要弄清楚这个递归流程  如果看文章看不明白可以debug跟进查看
	if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
		parse(bdCand.getBeanClassName(), holder.getBeanName());
	}
}
```

在上面这段代码中ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)这个判断里有一个小细节这里提一下，我们直接看这段代码中的部分(不把代码全贴出来，大家可以自己点进源码看)

```java
Map<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());
if (config != null && !Boolean.FALSE.equals(config.get("proxyBeanMethods"))) {
	beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
}
else if (config != null || isConfigurationCandidate(metadata)) {
	beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
}
else {
	return false;
}
```

> 这段代码中有一个获取@Configuration注解的proxyBeanMethods属性值的判断，这个其实是Spring配置类的一种类型/模式，具体这里也不分析了有点脱离主题，直接贴一下结论：
>
> 如果 Class上标注有@Component注解、@ComponentScan注解、@Import注解、@ImportResource注解、类上没有任何注解，存在@Bean方法、@Configuration(proxyBeanMethods = false) 这几种情况下认为是lite模式的配置类
>
> 那么对应的full模式就是上面代码中判断的@Configuration(proxyBeanMethods = true)这种情况下认为是 full模式
> 那么full和lite模式的区别是什么呢？
>
> 对于full模式：full模式下的配置类会被CGLIB代理生成代理类取代原始类型(在容器中)；full模式下的@Bean方法不能是private和final；单例scope下不同@Bean方法可以互相引用，达到单实例的语义
>
> 对于lite模式：lite模式下的配置类不生成代理，原始类型进入容器；lite模式下的@Bean方法可以是private和final；单例scope下不同@Bean方法引用时无法做到单例

好了关于full和lite模式就简单说这些，感兴趣的小伙伴可以再深入研究，细讲篇幅实在太长了，我们回到正题。

至此我们分析完了从SpringBoot启动类进入包扫描，然后获取所有扫描到的Bean对象的BeanDefinition，然后递归处理再次解析配置类，当被扫描到的Bean有@Bean注解时，会走org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法的@Bean注解处理流程，也就是这部分

```java
//这部分代码是org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass的一小段
//这段专门处理@Bean注解的

// Process individual @Bean methods
// 通过上面的分析我们知道了，对于我们例子中TestConfig类中有@Bean注解，所以我们这里认为代码运行到parse到TestConfig了
// 然后下面这一步的sourceClass其实就是TestConfig的SourceClass对象，在这一步获取TestConfig中的@Bean标记的方法
// 这个就不跟进去分析了  这一步获取到的就是Bean里面所有的@Bean标记的方法
Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
// 然后循环把这些添加到configClass记录
for (MethodMetadata methodMetadata : beanMethods) {
	configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
}
```

那么至此，经过SpringBoot启动类扫描了所有Bean，然后所有扫描出来的Bean也递归的parse完成了，那么就返回到org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions方法中的parser.parse(candidates);这一步，经过这些步骤之后，扫描到的所有的Bean对应的BeanDefinition也注册完成了。然后我们来看接下来该方法中的：this.reader.loadBeanDefinitions(configClasses);

### this.reader.loadBeanDefinitions(configClasses)解析

**ConfigurationClass**

`org.springframework.context.annotation.ConfigurationClass`，根据前面提到的**配置类**解析出来的对象，如下

```java
final class ConfigurationClass {
	/**
	 * 元数据信息，根据通过它获取**配置类** Class 对象的所有信息
	 */
	private final AnnotationMetadata metadata;

	private final Resource resource;

	@Nullable
	private String beanName;

	/**
	 * 假如这个 Class 对象是通过 @Import 注解被导入的
	 * 那么这个集合保存的就是该 @Import 注解标注的配置类，表示谁把它导入的
	 */
	private final Set<ConfigurationClass> importedBy = new LinkedHashSet<>(1);

	/**
	 * 带有 @Bean 注解的方法集合
	 */
	private final Set<BeanMethod> beanMethods = new LinkedHashSet<>();

	/**
	 * 需要导入的资源集合
	 */
	private final Map<String, Class<? extends BeanDefinitionReader>> importedResources = new LinkedHashMap<>();

	/**
	 * {@link Import} 注解导入的 ImportBeanDefinitionRegistrar 类型的对象
	 */
	private final Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> importBeanDefinitionRegistrars = new LinkedHashMap<>();

	/**
	 * 需要跳过的 @Bean 注解的方法集合
	 */
	final Set<String> skippedBeanMethods = new HashSet<>();


	/**
	 * Create a new {@link ConfigurationClass} with the given name.
	 * @param metadataReader reader used to parse the underlying {@link Class}
	 * @param beanName must not be {@code null}
	 * @see ConfigurationClass#ConfigurationClass(Class, ConfigurationClass)
	 */
	public ConfigurationClass(MetadataReader metadataReader, String beanName) {
		Assert.notNull(beanName, "Bean name must not be null");
		this.metadata = metadataReader.getAnnotationMetadata();
		this.resource = metadataReader.getResource();
		this.beanName = beanName;
	}
 	
    // ... 省略相关构造函数、getter、setter 方法
    
	public void validate(ProblemReporter problemReporter) {
		// A configuration class may not be final (CGLIB limitation)
		if (getMetadata().isAnnotated(Configuration.class.getName())) {
			if (getMetadata().isFinal()) {
				problemReporter.error(new FinalConfigurationProblem());
			}
		}
		for (BeanMethod beanMethod : this.beanMethods) {
			beanMethod.validate(problemReporter);
		}
	}

	@Override
	public boolean equals(Object other) {
		return (this == other || (other instanceof ConfigurationClass &&
				getMetadata().getClassName().equals(((ConfigurationClass) other).getMetadata().getClassName())));
	}

	@Override
	public int hashCode() {
		return getMetadata().getClassName().hashCode();
	}

}
```

在`org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions`方法中调用`this.reader.loadBeanDefinitions(configClasses);`时会传入之前已解析到的所有ConfigurationClass，这个Set有很多值，但是我们本次只分析@Bean的内容，所以我们就看TestConfig类的流程。跟进`org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions`方法

```java
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
	// 传入了所有的ConfigurationClass
	TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
	for (ConfigurationClass configClass : configurationModel) {
		// 由于我们只分析@Bean注解，所以我们就当成本次循环到了TestConfig类，然后跟进下面这个方法
		loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
	}
}
```

跟进`loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);`方法(假设此时入参是`TestConfig`的`ConfigurationClass` )

```java
private void loadBeanDefinitionsForConfigurationClass(
			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

	if (trackedConditionEvaluator.shouldSkip(configClass)) {
		String beanName = configClass.getBeanName();
		if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {
			this.registry.removeBeanDefinition(beanName);
		}
		this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
		return;
	}

	if (configClass.isImported()) {
		registerBeanDefinitionForImportedConfigurationClass(configClass);
	}
	// 前面我们分析的parse方法递归的过程中，TestConfig的@Bean方法会加载成MethodMetadata并添加到了configClass的BeanMethods中
	// 这里就是把之前解析并记录的BeanMethod 取出来循环load
	for (BeanMethod beanMethod : configClass.getBeanMethods()) {
		// load每一个BeanMethod 并转成BeanDefinition注册当工厂中
		loadBeanDefinitionsForBeanMethod(beanMethod);
	}

	loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
	loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
```

通过上面这段代码我们跟进：`loadBeanDefinitionsForBeanMethod(beanMethod);`

```java
private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
	ConfigurationClass configClass = beanMethod.getConfigurationClass();
	MethodMetadata metadata = beanMethod.getMetadata();
	String methodName = metadata.getMethodName();

	// Do we need to mark the bean as skipped by its condition?
	if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
		configClass.skippedBeanMethods.add(methodName);
		return;
	}
	if (configClass.skippedBeanMethods.contains(methodName)) {
		return;
	}
	
	//获取@Bean注解的属性值
	AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
	Assert.state(bean != null, "No @Bean annotation attributes");

	// Consider name and any aliases
	// 获取Bean的名称和别名
	List<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray("name")));
	// 如果@Bean注解的name属性为空，那么获取@Bean注解标记的方法的名字为beanName  否则就取name属性的第一个的值并将其删除
	// 在我们的例子TestConfig中，@Bean并没有name属性设置，所以@Bean标记方法生成的spring Bean对象的名称就是方法名：myTest
	String beanName = (!names.isEmpty() ? names.remove(0) : methodName);

	// Register aliases even when overridden
	for (String alias : names) {
		this.registry.registerAlias(beanName, alias);
	}

	//后续就是一些其他的属性设置和代理相关的  就不一个一个写了

	// Has this effectively been overridden before (e.g. via XML)?
	if (isOverriddenByExistingDefinition(beanMethod, beanName)) {
		if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {
			throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),
					beanName, "Bean name derived from @Bean method '" + beanMethod.getMetadata().getMethodName() +
					"' clashes with bean name for containing configuration class; please make those names unique!");
		}
		return;
	}

	ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata, beanName);
	beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));

	if (metadata.isStatic()) {
		// static @Bean method
		if (configClass.getMetadata() instanceof StandardAnnotationMetadata) {
			beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());
		}
		else {
			beanDef.setBeanClassName(configClass.getMetadata().getClassName());
		}
		beanDef.setUniqueFactoryMethodName(methodName);
	}
	else {
		// instance @Bean method
		beanDef.setFactoryBeanName(configClass.getBeanName());
		beanDef.setUniqueFactoryMethodName(methodName);
	}

	if (metadata instanceof StandardMethodMetadata) {
		beanDef.setResolvedFactoryMethod(((StandardMethodMetadata) metadata).getIntrospectedMethod());
	}

	beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
	beanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.
			SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);

	AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);

	Autowire autowire = bean.getEnum("autowire");
	if (autowire.isAutowire()) {
		beanDef.setAutowireMode(autowire.value());
	}

	boolean autowireCandidate = bean.getBoolean("autowireCandidate");
	if (!autowireCandidate) {
		beanDef.setAutowireCandidate(false);
	}

	String initMethodName = bean.getString("initMethod");
	if (StringUtils.hasText(initMethodName)) {
		beanDef.setInitMethodName(initMethodName);
	}

	String destroyMethodName = bean.getString("destroyMethod");
	beanDef.setDestroyMethodName(destroyMethodName);

	// Consider scoping
	ScopedProxyMode proxyMode = ScopedProxyMode.NO;
	AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
	if (attributes != null) {
		beanDef.setScope(attributes.getString("value"));
		proxyMode = attributes.getEnum("proxyMode");
		if (proxyMode == ScopedProxyMode.DEFAULT) {
			proxyMode = ScopedProxyMode.NO;
		}
	}

	// Replace the original bean definition with the target one, if necessary
	// 如有必要，将原始 bean 定义替换为代理目标
	BeanDefinition beanDefToRegister = beanDef;
	if (proxyMode != ScopedProxyMode.NO) {
		BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
				new BeanDefinitionHolder(beanDef, beanName), this.registry,
				proxyMode == ScopedProxyMode.TARGET_CLASS);
		beanDefToRegister = new ConfigurationClassBeanDefinition(
				(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata, beanName);
	}

	if (logger.isTraceEnabled()) {
		logger.trace(String.format("Registering bean definition for @Bean method %s.%s()",
				configClass.getMetadata().getClassName(), beanName));
	}
	// 到这里 @Bean标记的方法就被加载成BeanDefinition 并注入到工厂中
	this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
```

那么至此被扫描的配置类中@Bean标记的方法的BeanDefinition也被注册到工厂中了，后续在`org.springframework.context.support.AbstractApplicationContext#refresh`中实例化的时候，该对象就会被实例化并交由Spring管理

###参考资料

[死磕Spring之IoC篇 - @Bean 等注解的实现原理](https://www.cnblogs.com/lifullmoon/p/14461712.html)

[Spring的@Bean注解原理详解](https://blog.csdn.net/qq_34203492/article/details/126505543)

#  Lombok

## @Data

@Data 是一个 Lombok 提供的注解，它可以自动为类生成常用的方法，包括 getter、setter、equals、hashCode 和 toString 等。使用 @Data 注解可以简化代码，使代码更加简洁易读

# MongoDB

## @Document

@Document注解主要用于将Java类映射为MongoDB中的文档对象。在使用@Document注解时，需要指定该文档对象对应的集合名称、索引等元数据信息

@Document注解的源代码如下

```java
@Persistent
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Document {
    @AliasFor("collection")
    String value() default "";

    @AliasFor("value")
    String collection() default "";

    String language() default "";

    String collation() default "";
}
```

从注解的源代码可以看到，@Document注解有以下几个属性

- collection：指定该文档对象对应的集合名称；
- language：指定该文档对象的默认语言；
- strict：指定是否启用MongoDB的严格模式；
- indexOptions：指定该文档对象的索引选项；
- indexes：指定该文档对象的索引；
- collation：指定该文档对象的排序规则

# Jackson

## @JsonInclude

`@JsonInclude`是Jackson库中的一个注解，用于控制序列化和反序列化时对字段的包含策略。这个注解可以应用在类、getter方法或字段上。

`@JsonInclude`有以下几种值

- `JsonInclude.Include.ALWAYS`：默认值，表示总是包含字段，无论其值是否为null
- `JsonInclude.Include.NON_NULL`：只包含非null的字段。这是最常用的策略，可以避免序列化null值，从而减小生成的JSON大小
- `JsonInclude.Include.NON_ABSENT`：与NON_NULL类似，但会将null和未设置的值视为"absent"，因此不会被序列化
- `JsonInclude.Include.NON_DEFAULT`：只包含非默认值的字段。这意味着如果一个字段有默认值（例如int类型的0），并且其实际值等于默认值，则该字段不会被序列化
- `JsonInclude.Include.NON_EMPTY`：只包含非空的字段。对于字符串，这意味着不包括空字符串；对于集合，意味着不包括空集合；对于数字，意味着不包括0

**案例**

```java
public class User {
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String username;
    private String password;
    private Integer age;
    }

//测试代码
    public static void main(String[] args) throws IOException {
        User user = new User();
        ObjectMapper objectMapper = new ObjectMapper();
        String value = objectMapper.writeValueAsString(user);
        System.out.println(value);
    }

//结果
{"password":null,"age":null}
```

# 注释

## @see

注释为了更好的描述，需要引用和参考其他代码。为了让阅读者更好的体验，javadoc中支持链接跳转,这就需要用到注解`@see`

注解`@see`可以在注释中实现链接跳转

`@see`可以指向包，类，方法，属性.

一个完整的使用方法是@see package.class#member`.

如果指向的在当前类中,可以只写井号后面的

```java
/**
 * A factory for {@link MongoClient} instances.  Use of this class is now the recommended way to connect to MongoDB via the Java driver.
 *
 * @see MongoClient
 * @since 3.7
 */
public final class MongoClients {
    //
}
```











```java
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
   this.resourceLoader = resourceLoader;
   
   Assert.notNull(primarySources, "PrimarySources must not be null");
   
   this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
   
   // 获取应用类型，根据是否加载Servlet类判断是否是web环境
   this.webApplicationType = WebApplicationType.deduceFromClasspath();
   
   this.bootstrappers = new ArrayList<>(getSpringFactoriesInstances(Bootstrapper.class));
   
   // 读取META-INFO/spring.factories文件，获取对应的ApplicationContextInitializer装配到集合
   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
   
   // 设置所有监听器
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   
   // 推断main函数
   this.mainApplicationClass = deduceMainApplicationClass();
}
```

可以看到构造方法里主要做了这么几件事：

1. 根据是否加载servlet类判断是否是web环境
2. 获取所有初始化器，扫描所有`META-INF/spring.factories`下的ApplicationContextInitializer子类通过反射拿到实例，在spring实例启动前后做一些回调工作。
3. 获取所有监听器，同2，也是扫描配置加载对应的类实例。
4. 定位main方法



```java
/**
     * Run the Spring application, creating and refreshing a new
     * {@link ApplicationContext}.
     *
     * @param args the application arguments (usually passed from a Java main method)
     * @return a running {@link ApplicationContext}
     */
    public ConfigurableApplicationContext run(String... args) {
        // 启动一个秒表计时器，用于统计项目启动时间
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 创建启动上下文对象即spring根容器
        DefaultBootstrapContext bootstrapContext = createBootstrapContext();
        // 定义可配置的应用程序上下文变量
        ConfigurableApplicationContext context = null;
        /**
         * 设置jdk系统属性
         * headless直译就是无头模式，
         * headless模式的意思就是明确Springboot要在无鼠键支持的环境中运行，一般程序也都跑在Linux之类的服务器上，无鼠键支持，这里默认值是true；
         */
        configureHeadlessProperty();
        /**
         * 获取运行监听器 getRunListeners, 其中也是调用了上面说到的getSpringFactoriesInstances 方法
         * 从spring.factories中获取配置
         */
        SpringApplicationRunListeners listeners = getRunListeners(args);
        // 启动监听器
        listeners.starting(bootstrapContext, this.mainApplicationClass);
        try {
            // 包装默认应用程序参数，也就是在命令行下启动应用带的参数，如--server.port=9000
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            //
            /**
             * 准备环境 prepareEnvironment 是个硬茬，里面主要涉及到
             * getOrCreateEnvironment、configureEnvironment、configurePropertySources、configureProfiles
             * environmentPrepared、bindToSpringApplication、attach诸多方法可以在下面的例子中查看
             */
            ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
            // 配置忽略的 bean
            configureIgnoreBeanInfo(environment);
            // 打印 SpringBoot 标志，即启动的时候在控制台的图案logo，可以在src/main/resources下放入名字是banner的自定义文件
            Banner printedBanner = printBanner(environment);
            // 创建 IOC 容器
            context = createApplicationContext();
            // 设置一个启动器，设置应用程序启动
            context.setApplicationStartup(this.applicationStartup);
            // 配置 IOC 容器的基本信息 (spring容器前置处理)
            prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
            /**
             * 刷新IOC容器
             * 这里会涉及Spring容器启动、自动装配、创建 WebServer启动Web服务即SpringBoot启动内嵌的 Tomcat
             */
            refreshContext(context);
            /**
             * 留给用户自定义容器刷新完成后的处理逻辑
             * 刷新容器后的扩展接口(spring容器后置处理)
             */
            afterRefresh(context, applicationArguments);
            // 结束计时器并打印，这就是我们启动后console的显示的时间
            stopWatch.stop();
            if (this.logStartupInfo) {
                // 打印启动完毕的那行日志
                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
            }
            // 发布监听应用上下文启动完成（发出启动结束事件），所有的运行监听器调用 started() 方法
            listeners.started(context);
            // 执行runner，遍历所有的 runner，调用 run 方法
            callRunners(context, applicationArguments);
        } catch (Throwable ex) {
            // 异常处理，如果run过程发生异常
            handleRunFailure(context, ex, listeners);
            throw new IllegalStateException(ex);
        }

        try {
            // 所有的运行监听器调用 running() 方法,监听应用上下文
            listeners.running(context);
        } catch (Throwable ex) {
            // 异常处理
            handleRunFailure(context, ex, null);
            throw new IllegalStateException(ex);
        }
        // 返回最终构建的容器对象
        return context;
    }
```

因此，注解是将参数信息存储到了class文件的常量池里面，在创建实例的时候，会通过getConstantPool()获取出来，是一个byte[]流，需要进行转换

**最终总结**

- 注解@interface 是一个实现了Annotation接口的 接口， 然后在调用getDeclaredAnnotations()方法的时候，返回一个代理$Proxy对象，这个是使用jdk动态代理创建，使用Proxy的newProxyInstance方法时候，传入接口 和InvocationHandler的一个实例(也就是 AnotationInvocationHandler ) ，最后返回一个代理实例
- 期间，在创建代理对象之前，解析注解时候 从该注解类的常量池中取出注解的信息，包括之前写到注解中的参数，然后将这些信息在创建 AnnotationInvocationHandler时候 ，传入进去 作为构造函数的参数
  





