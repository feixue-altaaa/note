#  Lombok

## @Data

@Data 是一个 Lombok 提供的注解，它可以自动为类生成常用的方法，包括 getter、setter、equals、hashCode 和 toString 等。使用 @Data 注解可以简化代码，使代码更加简洁易读

# MongoDB

## @Document

@Document注解主要用于将Java类映射为MongoDB中的文档对象。在使用@Document注解时，需要指定该文档对象对应的集合名称、索引等元数据信息

@Document注解的源代码如下

```java
@Persistent
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Document {
    @AliasFor("collection")
    String value() default "";

    @AliasFor("value")
    String collection() default "";

    String language() default "";

    String collation() default "";
}
```

从注解的源代码可以看到，@Document注解有以下几个属性

- collection：指定该文档对象对应的集合名称；
- language：指定该文档对象的默认语言；
- strict：指定是否启用MongoDB的严格模式；
- indexOptions：指定该文档对象的索引选项；
- indexes：指定该文档对象的索引；
- collation：指定该文档对象的排序规则

# Jackson

## @JsonInclude

`@JsonInclude`是Jackson库中的一个注解，用于控制序列化和反序列化时对字段的包含策略。这个注解可以应用在类、getter方法或字段上。

`@JsonInclude`有以下几种值

- `JsonInclude.Include.ALWAYS`：默认值，表示总是包含字段，无论其值是否为null
- `JsonInclude.Include.NON_NULL`：只包含非null的字段。这是最常用的策略，可以避免序列化null值，从而减小生成的JSON大小
- `JsonInclude.Include.NON_ABSENT`：与NON_NULL类似，但会将null和未设置的值视为"absent"，因此不会被序列化
- `JsonInclude.Include.NON_DEFAULT`：只包含非默认值的字段。这意味着如果一个字段有默认值（例如int类型的0），并且其实际值等于默认值，则该字段不会被序列化
- `JsonInclude.Include.NON_EMPTY`：只包含非空的字段。对于字符串，这意味着不包括空字符串；对于集合，意味着不包括空集合；对于数字，意味着不包括0

**案例**

```java
public class User {
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String username;
    private String password;
    private Integer age;
    }

//测试代码
    public static void main(String[] args) throws IOException {
        User user = new User();
        ObjectMapper objectMapper = new ObjectMapper();
        String value = objectMapper.writeValueAsString(user);
        System.out.println(value);
    }

//结果
{"password":null,"age":null}
```

# 注释

## @see

注释为了更好的描述，需要引用和参考其他代码。为了让阅读者更好的体验，javadoc中支持链接跳转,这就需要用到注解`@see`

注解`@see`可以在注释中实现链接跳转

`@see`可以指向包，类，方法，属性.

一个完整的使用方法是@see package.class#member`.

如果指向的在当前类中,可以只写井号后面的

```java
/**
 * A factory for {@link MongoClient} instances.  Use of this class is now the recommended way to connect to MongoDB via the Java driver.
 *
 * @see MongoClient
 * @since 3.7
 */
public final class MongoClients {
    //
}
```











```java
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
   this.resourceLoader = resourceLoader;
   
   Assert.notNull(primarySources, "PrimarySources must not be null");
   
   this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
   
   // 获取应用类型，根据是否加载Servlet类判断是否是web环境
   this.webApplicationType = WebApplicationType.deduceFromClasspath();
   
   this.bootstrappers = new ArrayList<>(getSpringFactoriesInstances(Bootstrapper.class));
   
   // 读取META-INFO/spring.factories文件，获取对应的ApplicationContextInitializer装配到集合
   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
   
   // 设置所有监听器
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   
   // 推断main函数
   this.mainApplicationClass = deduceMainApplicationClass();
}
```

可以看到构造方法里主要做了这么几件事：

1. 根据是否加载servlet类判断是否是web环境
2. 获取所有初始化器，扫描所有`META-INF/spring.factories`下的ApplicationContextInitializer子类通过反射拿到实例，在spring实例启动前后做一些回调工作。
3. 获取所有监听器，同2，也是扫描配置加载对应的类实例。
4. 定位main方法



```java
/**
     * Run the Spring application, creating and refreshing a new
     * {@link ApplicationContext}.
     *
     * @param args the application arguments (usually passed from a Java main method)
     * @return a running {@link ApplicationContext}
     */
    public ConfigurableApplicationContext run(String... args) {
        // 启动一个秒表计时器，用于统计项目启动时间
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 创建启动上下文对象即spring根容器
        DefaultBootstrapContext bootstrapContext = createBootstrapContext();
        // 定义可配置的应用程序上下文变量
        ConfigurableApplicationContext context = null;
        /**
         * 设置jdk系统属性
         * headless直译就是无头模式，
         * headless模式的意思就是明确Springboot要在无鼠键支持的环境中运行，一般程序也都跑在Linux之类的服务器上，无鼠键支持，这里默认值是true；
         */
        configureHeadlessProperty();
        /**
         * 获取运行监听器 getRunListeners, 其中也是调用了上面说到的getSpringFactoriesInstances 方法
         * 从spring.factories中获取配置
         */
        SpringApplicationRunListeners listeners = getRunListeners(args);
        // 启动监听器
        listeners.starting(bootstrapContext, this.mainApplicationClass);
        try {
            // 包装默认应用程序参数，也就是在命令行下启动应用带的参数，如--server.port=9000
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            //
            /**
             * 准备环境 prepareEnvironment 是个硬茬，里面主要涉及到
             * getOrCreateEnvironment、configureEnvironment、configurePropertySources、configureProfiles
             * environmentPrepared、bindToSpringApplication、attach诸多方法可以在下面的例子中查看
             */
            ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
            // 配置忽略的 bean
            configureIgnoreBeanInfo(environment);
            // 打印 SpringBoot 标志，即启动的时候在控制台的图案logo，可以在src/main/resources下放入名字是banner的自定义文件
            Banner printedBanner = printBanner(environment);
            // 创建 IOC 容器
            context = createApplicationContext();
            // 设置一个启动器，设置应用程序启动
            context.setApplicationStartup(this.applicationStartup);
            // 配置 IOC 容器的基本信息 (spring容器前置处理)
            prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
            /**
             * 刷新IOC容器
             * 这里会涉及Spring容器启动、自动装配、创建 WebServer启动Web服务即SpringBoot启动内嵌的 Tomcat
             */
            refreshContext(context);
            /**
             * 留给用户自定义容器刷新完成后的处理逻辑
             * 刷新容器后的扩展接口(spring容器后置处理)
             */
            afterRefresh(context, applicationArguments);
            // 结束计时器并打印，这就是我们启动后console的显示的时间
            stopWatch.stop();
            if (this.logStartupInfo) {
                // 打印启动完毕的那行日志
                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
            }
            // 发布监听应用上下文启动完成（发出启动结束事件），所有的运行监听器调用 started() 方法
            listeners.started(context);
            // 执行runner，遍历所有的 runner，调用 run 方法
            callRunners(context, applicationArguments);
        } catch (Throwable ex) {
            // 异常处理，如果run过程发生异常
            handleRunFailure(context, ex, listeners);
            throw new IllegalStateException(ex);
        }

        try {
            // 所有的运行监听器调用 running() 方法,监听应用上下文
            listeners.running(context);
        } catch (Throwable ex) {
            // 异常处理
            handleRunFailure(context, ex, null);
            throw new IllegalStateException(ex);
        }
        // 返回最终构建的容器对象
        return context;
    }
```







