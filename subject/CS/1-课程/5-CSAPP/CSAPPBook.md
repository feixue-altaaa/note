# 计算机系统漫游

## **信息就是位 + 上下文**

- 程序的生命周期从**源程序（源文件）**开始。源程序实际上就是由 0 和 1 组成的位序列
- 一般用 **ASCII 标准**来表示**文本字符**，实际上是用一个字节的整数值来表示一种字符
- 源文件中每个文本行都是以看不见的 '\n' 结束的
- 只由 ASCII 字符组成的文件成为**文本文件**，其他都是**二进制文件**。.cpp 文件就是文本文件
- 系统中的所有信息都是由一串比特（bit：位）表示的，区分不同数据对象的**唯一方法**就是根据上下文

### **C 语言的特点**

- C 语言小而简单
- C 语言是为了实现 unix 而设计的
- C 语言与 unix 关系密切

C 语言是**系统级编程**的首选，也非常适用于应用级程序

## **程序被其他程序翻译成不同的格式**

从源程序到目标程序要经历**四个步骤**

- 源程序被**预处理器**处理得到**修改了的源程序**（文本文件，hello.i）
- 再由**编译器**处理得到**汇编程序**（文本文件,hello.s）
- 汇编程序由**汇编器**处理得到**可重定位目标程序**（二进制文件,hello.o）
- 最后由**链接器**链接得到**可执行目标程序**（二进制文件,hello）

**预处理阶段**

- 预处理器根据 # 开头的命令修改原始的 c 程序。比如根据 #include 命令把头文件 stdio.h 的内容直接插入到程序文件中

**编译阶段**

**汇编阶段**

**链接阶段**

- 比如 printf 函数是一个标准 C 库函数，存在于 printf.o 中，这是一个单独的预编译好了的目标文件。链接器将其与汇编得到的二进制文件合并得到可执行目标文件

##  **了解编译系统如何工作是大有用处的**

**用处**

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞

## **处理器**读并解释储存在内存中的指令

shell 是一个命令行解释器，它输出一个提示符（>>），等待输入一个命令行，然后执行命令。如果输入的是可执行文件的名字，就运行该文件

 ### **系统的硬件组成**

主要包括**总线、I/O 设备、处理器、主存储器**四个部分

**总线**

- 总线一次可以传输一个定长的字节块，称为字。64位系统即总线一次可以传输 64 位（8字节），这里一个字就是 8 字节

**I/O 设备**

- 每个 I/O 设备通过一个**控制器**或**适配器**与 I/O 总线相连
- **控制器**是 I/O 设备本身或主板上的芯片组，**适配器**则是一块插在主板上的卡

**主存**

- 主存是由一组**动态随机存取内存（DRAM）**组成的
- 从逻辑上看，存储器是一个线性的字节数组，每个字节都有唯一的地址

**处理器**

- 处理器是**解释存储在主存中指令**的引擎
- 处理器的**核心**是一个**程序计数器（PC)**
- 程序计数器是一个大小为**一个字**的存储设备，存储CPU即将执行的**下一条指令的地址**
- 处理器就是在不断执行程序计数器指向的指令。每执行一条，程序计数器更新一次，指向下一条指令
- 处理器会按照**指令执行模型（指令集架构）**解释指令中的位并执行相应操作
- 每条指令的操作是围绕**主存、寄存器文件、算数/逻辑单元（ALU）**进行的
- **寄存器文件**：单个字长，有唯一的名字
- **ALU：**计算新的数据和地址值

几个简单指令的操作

- **加载**：从主存复制一个字或字节到寄存器，覆盖原来内容
- **存储**：从寄存器复制一个字或字节到主存，覆盖原来内容
- **操作**：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并把结果存到一个寄存器中
- **跳转**：从指令中抽取一个字复制到程序计数器中，覆盖原来内容

区分处理器指令集架构和微体系架构

- **指令集架构：**每条机器指令的效果
- **微体系架构：**处理器实际上是如何实现的

### **运行 hello 程序**

执行目标文件时，shell 程序将位于磁盘目标文件中的字符逐个读入寄存器，然后放到主存中。之后处理器就开始执行目标文件的机器语言指令，从 main 程序开始

利用**直接存储器存取（DMA）**可以不通过寄存器，直接将数据从磁盘到达内存

以输出打印 hello world 为例，处理器将 hello world 的字节复制到寄存器，然后再复制到显示器，最后显示在屏幕上

**整个流程：**读取文件字符到寄存器 → 存储到主存  → 执行指令  →  **加载 helloworld 到寄存器 → 复制到显示器 → 显示**

### **高速缓存至关重要**

从主存读取一个字比磁盘快 **1000 万**倍

从寄存器文件读取比主存块 **100 倍**，并且差距还在加大

高速缓存（cache）用来解决处理器与主存间的差异

**L1 高速缓存**位于 **CPU** 上，容量为数万字节（**几十 MB**）。L1 比 L2 快 **5** 倍

**L2 高速缓存**通过**一条特殊的总线**与 CPU 连接，容量为数十万到数百万字节（**几百 MB 到 几 GB**）。L2 比 主存快 **5~10** 倍

新的系统还有 L3

通过让高速缓存里存放可能经常访问的数据，让大部分的内存操作都在高速缓存中完成

### **存储设备形成层次结构**

存储器层次结构共 7 层，**主要思想**是上一层的存储器作为低一层的高速缓存

从上到下，容量更大，运行更慢，每字节价格更便宜

- 0层：寄存器
- 1层：L1高速缓存(SRAM)
- 2层：L2高速缓存(SRAM)
- 3层：L3高速缓存（SRAM）
- 4层：主存（DRAM）
- 5层：本地二级存储（本地磁盘）
- 6层：远程二级存储（分布式文件系统，Web服务器）

## **操作系统管理硬件**

操作系统的**两个基本功能**

- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂的低级硬件设备

操作系统所应用的**三个基本的抽象概念**

- **进程**：对处理器、主存和 I/O 设备的抽象表示
- **虚拟内存**：对主存和磁盘的抽象表示
- **文件**：对 I/O 设备的抽象表示

### **进程**

**进程：**对操作系统正在运行的程序的一种抽象

**并发运行：**一个进程的指令和另一个进程的指令是交错执行的

一个系统可以同时运行多个进程，实际上这些进程是并发运行的

操作系统通过**上下文切换**来实现并发运行。上下文是跟踪进程运行所需的所有**状态信息**，可能存在于PC、寄存器文件、主存等地方

**任何时刻，单处理器只能执行一个进程的代码**

操作系统**内核**是操作系统代码常驻主存的部分，从一个进程到另一个进程的转换是由内核管理的

内核不是一个独立的进程，是一系列代码和数据结构的集合

当应用程序需要操作系统的某些操作时，就把控制权传递给内核，内核执行完操作后返回应用程序

### **线程**

**一个进程由多个线程组成**，每个线程都运行在进程的上下文中，共享同样的代码和全局数据

多线程之间比多进程之间更容易共享数据，且线程一般来说比进程更高效

### **虚拟内存**

机器级程序将内存视为一个庞大的字节数组，称为**虚拟内存**。

内存的每个字节由地址来标识，所有可能地址的集合就是**虚拟地址空间。**

虚拟内存使每个进程都以为自己独占了主存。每个进程看到的内存都是**一致的**，即**虚拟地址空间**。

在linux中，每个进程看到的虚拟地址空间由以下几个部分组成：

1. **程序代码和数据**
2. **堆（运行时堆）**
3. **共享库**
4. **栈（用户栈）**
5. **内核虚拟内存**

地址从低到高，最高层的**内核虚拟内存**保存的是操作系统中的代码和数据，这部分每个进程都一样。

**程序代码和数据**

对所有进程来说，代码都是从同一个固定地址开始，紧接着是与全局变量对应的数据区。代码和数据区都是按照可执行文件的内容初始化的。代码和数据区在进程开始运行时就被指定了大小。

**堆**

而运行时堆是根据 malloc 和 free 函数的调用在运行时**动态地**扩展和收缩的。

**共享库**

地址空间的中间部分用来存放共享库的代码和数据。如 C 标准库、数学库等都属于共享库

**栈**

用户栈和堆一样，在程序执行期间可以**动态的扩展和收缩**，编译器用它来**实现函数调用**。当调用函数时，栈增长，从函数返回时，栈收缩

### **文件**

文件就是**字节序列**，仅此而已

每个 I/O 设备，包括磁盘、键盘、显示器、网络，都可以看成是文件

## **系统之间利用网络通信**

从一个单独的系统而言，网络可以视为一个 I/O 设备

以在一个远端服务器运行程序为例，在本地输入，在远端执行，执行结果发送回本地输出

## **重要主题**

###  Amdahl 定律

Amdahl 定律的主要观点：要加速整个系统，必须提升全系统中相当大的部分

### **并发和并行**

区分并发与并行

- **并发：**一个通用的概念，指一个同时具有多个活动的系统
- **并行：**用并发来使系统运行得更快

并行可以在多个抽象层次上运用。从高到低有以下三个层次

**线程级并行**

传统意义上的并发执行是通过单处理器在进程间快速切换**模拟**出来的。

多处理器系统由一个操作系统控制多个 CPU。结构如下

​    ![0](https://note.youdao.com/yws/public/resource/7147b6236213e667ab56314fbf660282/xmlnote/D80DE2E8D97D42B880DF956960E69A3C/10043)

L1 高速缓存被分为两个部分：一个保存最近取到的指令，一个存放数据。

**超线程**又称**同时多线程**，它允许一个 CPU 执行多个控制流。 CPU 有的硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件只有一份，比如浮点算术运算单元。常规 CPU 需要约 **20000** 个时钟周期来切换线程，超线程 CPU 可以在**单个周期**的基础上切换线程，比如一个线程在等待数据装在到高速缓存，CPU 就可以去执行另一个线程。

i7 处理器每个核执行两个线程，所以是 **4 核 8 线程**，8 个线程都并行执行。

**指令级并行**

每条指令从开始到结束一般需要 20 个或更多的时钟周期，通过指令级并行，可以实现每个周期 2~4 条指令的执行速率。

如果比一个周期一条指令更快，就称为**超标量处理器**，现在一般都是超标量。

**单指令、多数据并行**

在最低层次上，现代处理器允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行，即 SIMD 并行

###  **计算机系统中抽象的重要性**

​    ![0](https://note.youdao.com/yws/public/resource/7147b6236213e667ab56314fbf660282/xmlnote/756D80B52E184DF581F30CFE26E1000A/10084)

**指令集架构**是对 CPU 硬件的抽象，使用这个抽象，CPU 看起来好像一次只执行机器代码程序的一条指令，实际上底层硬件并行地执行多条指令

**虚拟机**是对整个计算机系统的抽象，包括操作系统、处理器和程序

# 程序结构和执行

## **信息的表示和处理**

计算机使用二值信号存储和表示信息

当计算结果太大以至于不能表示时，就会产生**溢出**

浮点数表示的精度有限，因而浮点运算是不可结合的

整数的表示范围小但是精确，浮点数表示的范围大但是是近似的

许多安全漏洞是由算术运算的微妙细节导致的

### **信息存储**

计算机一般使用字节作为最小的可寻址的内存单位。

在机器级程序中不包含关于数据类型的信息。

指针的值是某个存储块的第一个字节的**虚拟地址**。

**每个程序对象可以视为一个字节块**

#### **十六进制表示法**

十六进制以 0x 开头。

A：10；C:12；F：15

#### **字数据大小**

每个计算机有对应的字长，虚拟地址用一个字来编码，所以**字长决定了虚拟地址空间的大小**。**64 位机器的指针类型长度为 8 字节**

32位程序和64位程序的区别是如何编译的，而不是气运行的机器类型

32位机器的虚拟地址空间为 **4GB**，64 位字长的虚拟地址空间位 16 EB

**int32_t** 和 **int64_t** 类型分别为 4 字节和 8 字节，不受机器影响。使用确定大小的整数类型很有用

对 32 位和 64 位程序而言，char、short、int、long long 长度都是一样的，为  1，2，4，8。long 的长度不一样（32位程序：4字节；64位：8字节）

float 和 double 的长度一样，分别为 4，8

程序对 char 有无符号一般不敏感

#### **寻址和字节顺序**

对于跨越多字节的对象，它的地址是它所用字节中的**最小地址**。

**两种字节存储法**

- **小端法**：数字的低位在前（前就是最小地址）
- **大端法**：数字的高位在前

大多数 Intel 都是小端法，不是所有

#### **表示字符串**

- C 语言字符串是以 null 字符结尾的字符数组，即 '\0'
- ASCII 字符适合编码英文文档
- Unicode（UTF-8）使用 **4 字节**表示字符，一些常用的字符只需要 1 或 2 个字节。所有 ASCII 字符在 UTF-8 中是一样的
- JAVA 使用 UTF-8 来编码字符串

#### **表示代码**

二进制代码是**不兼容**的，一般无法在不同机器间移植。

从机器的角度看，**程序就是一个字节序列**

 #### **布尔代数**

**布尔代数**是在 0 和 1 基础上的定义

可以把字节看作是一个长为 8 的**位向量**。

位向量的一个应用是表示有限集合。如位向量 [0110 1001] 表示集合 A = {0,3,5,6}

#### **C 语言中的位级运算**

位运算的常见应用是实现**掩码**。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8 位。

表达式 **~0** 可以生成一个全 1 的掩码，不管机器的字大小是多少

#### **C 语言中的逻辑运算**

逻辑运算符 && 和 || 如果第一个参数就能确定结果，就不再计算第二个参数

>  && 和 ||与 &和 |区别
>
> + 前者为逻辑运算符，返回值为1/0；后者为位级运算符，返回值为运算结果
> + 前者会发生逻辑运算中的短路

#### **C 语言中的移位运算**

左移 k 位丢掉最高的 k 位，并在右端补 k 个 0

右移分为**逻辑右移**和**算术右移**。**逻辑右移左端补 0，算术右移左端补最高有效位的值**

一般都对有符号数使用算术右移，即补符号位的值。无符号数，**只能是逻辑右移**，即补 0

> **为什么算术左移和逻辑左移一样**
>
> 首先需要明确几个概念
>
> - 计算机操作的都是补码
> - 正数的补码和原码相同，负数的补码等于原码取反后+1
> - 需要先确定位数（如8位、16位、32位），因为有可能会出现溢出的情况
>
> 算术左移是带符号左移操作。它用于对带符号整数进行左移，保持数的符号位不变。
>
> 在算术左移中，最高位（符号位）的值会在左移时保持不变。左移后的空位用零填充。
>
> 在不溢出的情况下相当于乘以2。 
>
> 算术左移与逻辑左移相似，但对于有符号整数，它保留了符号位。 
>
> 例如原始：11111110 ----- -2
>
> 左移一位：11111100 ----- -4
>
> 注意：在不溢出的前提下（如8位的范围是-128-127），算术右移和逻辑右移的结果一样
>
> 其实左移一位相当于数乘以2之后的结果，现在假设有符号数占8位，表示负数范围为 -1 ~ -128，如果当前被左移数是（-1~-64)，在乘以2之后都是处于合法范围，而处于这个范围的数字的补码的第二位都是1，因此不需要考虑算术右移的符号位

### **整数表示**

无符号表示与补码表示

有符号数到无符号数的转换会产生漏洞，**避免错误的方法之一是绝不使用无符号数**。

除了 C 以外**很少有语言支持无符号整数**，Java 就只支持有符号数

#### **整数数据类型**

在 64 位系统上

- i**nt**：4字节，可表示十进制数字位数：**10位（-20~20亿以内）**
- **long long**：8字节，可表示十进制数字位数：**19位（千亿亿级）**
- long：8字节
- **double**：8字节，**精度15位**，可表示十进制数字位数**308位**
- **float**：4字节，**精度6位**，可表示十进制数字**38位**
- **char**：**-128~127**

java 只支持有符号数

#### **无符号数的编码**

无符号表示、补码表示与数据的映射都是双射，即一一对应

#### **补码编码**

补码的定义实际就是**将符号位解释为负权**

+ 补码是不对称的，因为一半的位模式表示为负数，另一半为非负数

- |TMin| = |TMax| + 1
- UMax = 2TMax + 1

C 库头文件  定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、UINT_MAX

C 库头文件 中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数

#### **有符号数和无符号数之间的转换**

在有符号数与无符号数之间进行强制类型转换的结果是**保持位值不变，只改变解释位的方式**

**补码 x 转无符号数**

- x >= 0，值不变
- x < 0，转换后的值为 2^w + x

**无符号数 x 转补码**

- x < 2^(w-1)，值不变
- x >= 2^(w-1)，转换后的值为 x - 2^w

#### **C 语言中的有符号数和无符号数**

- C 语言中有符号数和无符号数相加减，**有符号被转换成无符号**
- 相互转换时：数值可能会变，但是位模式不变

#### **扩展一个数字的位表示**

- 扩展无符号数使用零扩展，即在最高位前加 0
- 扩展有符号数使用符号扩展，即在最高位前加最高有效位的值（使用最高有效位进行填充）

 #### **截断数字**

对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位

+ 截断无符号数：截断后的数字实际上等于 x mod 2^k，即取余
+ 截断补码数值：x = U2T(x mod 2^k)

### **整数运算**

#### **无符号加法**

考虑溢出，**C 语言不会将溢出作为错误发出信号**

当 x+y >= 2^w，实际结果为 s = x+y-2^w

对任意的 x+y，**s = (x+y) % 2^w**

**溢出的结果：**和小于两个加数

**检验溢出的方式：**如果 **s，说明溢出**

**无符号数的非**：~x = **2^w** - x (x>0)

#### **补码加法**

> w为总位数（包含符号位）

当 x+y >= 2^(w-1)， s = x+y-2^w

+ 例如从四位溢出到五位，最高位一定为0，次高位一定为1，截断之后最高位变为1，需加-2^4

当 x+y < -2^(w-1)，s = x+y+2^w

+ 例如从四位溢出到五位，最高位一定为1，次高位一定为0，截断之后最高位变为0，需加2^4（因为之前已经减了）

else s = x+y

**正溢出的结果是负数，负溢出的结果是正数**

**检验溢出的方式：**当 x,y>0 而 s<=0 是正溢出；当 x,y<0 而 s>=0 是负溢出

#### **补码的非**

当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x

**补码非的位级表示：**对每一位求补，结果再加 1

**计算补码非的第二种方法：**假设 k 是最右边的 1 的位置，对 k 左边的所有位取反

#### **无符号乘法**

**无符号乘法的积** **m = (x\*y) % 2^w**

#### **补码乘法**

可以认为补码乘法和无符号乘法的**位级表示**是一样的

C语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释

**补码乘法的积** **m = (x\*y) % 2^w**

#### **乘以常数**

大多数机器上，整数乘法需要 **10 个或更多**的时钟周期，而加法、减法、位级运算和移位只需要 1 个时钟周期

**编译器对整数乘法进行优化的方式**：用**移位和加法或减法**运算的组合来代替常数因子的乘法。

左移 k 位等于乘以 2^k

如 x * 14  =  (x<<3)+(x<<2)+(x<<1)   =   (x<<4)-(x<<2)

**判断如何移动的方式**很简单：14 的位级表示为 1110，所以分别左移 3，2，1

#### **除以 2 的幂**

大多数机器上，整数除法更慢，需要 **30 个或更多**的始终周期。

（只有）除以 2 的幂可以用移位运算来代替，**无符号采用**逻辑右移，补码采用**算术右移**

> 整数除法总是舍入到0
>
> 即向下舍入一个正值，向上舍入一个负值

对于有符号数而言，x>=0 时，算术右移和逻辑右移效果相同；但x<0 时，算术右移的结果相当于**向下舍入**

+ 为了修正这种不合适的舍入，可以在移位前偏置这个值
+ 使用 **(x+(1<<k)-1)>>k** 的结果相当于进行除法运算然后**向零舍入**

 #### **关于整数运算的最后思考**

**补码使用了与无符号算术运算相同的位级实现**，包括加法、减法、乘法甚至除法。都有完全一样或非常类似的位级行为

### **浮点数**

浮点数对于非常大，非常接近零，近似值计算都很有用

#### **二进制小数**

有限长度编码：小数的二进制表示法只能表示那些能够写为 **x \* 2^w** 的数，**其他的数都是近似表示。x 必须可以由形如 2^i + 2^j + ... + 2^n 的多项式表示**

浮点运算的不精确性可能产生严重后果

####  **IEEE 浮点表示**

**IEEE 浮点标准**的表示形式为：**V = (-1)^S \* M \* 2^E**，它分为三部分

- **符号**：**S** 决定是负数还是正数
- **阶码**：**E** 的作用是对浮点数加权
- **尾数**：**M** 是一个二进制小数，范围是 1~2-ε 或 0~1-ε

**在对浮点数的位编码**时

- 一个单独的符号位编码直接编码 S
- k 位的**阶码字段 e** 编码 E；float 中 k=8，double 中 **k=11**
- n 位的**小数字段 f** 编码 M；float 中 n=23，double 中 **n=52**

E 和 M 的编码方式分为**三种情况**

- **规格化的值：**阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）

- - 阶码字段解释方式：**E = e - (2^(k-1)-1)**；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127
  - 小数字段解释方式：**M = 1 + f**

- **非规格化的值**：阶码字段全为 0 时属于非规格化形式

- - 阶码字段解释方式：**E = 1 - (2^(k-1)-1)**；**与规格化值中 e = 1 时的 E 相同**
  - 小数字段解释方式：**M = f**

- **特殊值：**阶码字段全为 1 时，分两种情况：

- - **小数字段全为 0：表示无穷**
  - **小数字段非零：表示 NaN。**比如 ∞-∞ 的结果就返回 NaN

#### **数字示例**

0 有 +0.0 和 -0.0 两种表示方式

最大非规格化数到最小规格化数的过渡是平滑的。

浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升序负数降序）。

浮点数可表示的数的分布是不均匀的，越接近零时越稠密

**几个特殊的值的位级表示**

- +0.0 全为 0
- **最小的正非规格化值：**最低有效位为 1，其他为 0
- **最大的非规格化值：**小数字段全为 1，其他为 0
- **最小的正规格化值：**阶码字段最低位为 1，其他为 0
- **最大的规格化值：**阶码字段最低位为 0，符号位为 0，其他为 1

#### **舍入**

因为范围和精度有限，浮点运算只能近似表示实数运算

在浮点数的近似匹配上，IEEE 浮点格式定义了**四种舍入方式（默认第一种）**

- **向偶数舍入（向最接近的值舍入）**：非中间值 (0.5) 四舍五入，中间值向偶数舍入
- 向零舍入
- 向下舍入
- 向上舍入

向偶数舍入可以计算一组数的平均数时避免统计偏差

实际上这种舍入是发生在二进制小数上的

#### **浮点运算**

IEEE 标准定义 1/-0 = -∞，1/+0 = +∞

浮点运算是**可交换不可结合也不可分配**的

浮点加法满足**加法和乘法上的单调性**。如果 a>=b，则 x+a >= x+b

缺乏结合性和分配性会使一些简单问题变得很复杂

#### **C 语言中的浮点数**

在 int、float、double 间进行**强制类型转换时的几种情况**

- int 到 float：不会溢出，可能舍入
- int 或 float 到 double：不会溢出也不会舍入
- double 到 float：可能溢出和舍入
- **float 或 double 到 int：**向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，转变结果都为 [1000]，因此一个正浮点可能得到一个负整数

**把大的浮点数转换为整数是一种常见的错误**

**要小心地使用浮点运算**









## 程序的机器码表示



> ### 栈向下增长的原因
>
> 我们都知道X86系统进程中堆栈都向下增长的，那为什么是向下增长呢？
>
> “这个问题与虚拟地址空间的分配规则有关，每一个可执行C程序，从低地址到高地址依次是：text，data，bss，堆，栈，环境参数变量；其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨。”
>
> 这样设计可以使得堆和栈能够充分利用空闲的地址空间。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！！
>
> ![11](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202401022219704.gif)

## 处理器体系结构

## 优化程序性能

## 存储器层次结构

# 在系统上运行程序

## 链接

## 异常控制流

## 虚拟内存

# 程序间的交互和通信

## 系统级IO

## 网络编程

## 并发编程





