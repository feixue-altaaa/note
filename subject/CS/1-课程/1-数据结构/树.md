# 红黑树与平衡二叉树的区别

## 红黑树的性质

- 节点是红色或黑色

- 根节点是黑色
- 每个叶子节点都是黑色的空节点（NIL节点）
- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树

## 平衡二叉树的性质

它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多

## 区别

红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知

# PriorityQueue

PriorityQueue，优先队列。**优先队列的作用是能保证每次取出的元素都是队列中权值最小的**（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，**元素大小的评判可以通过元素本身的自然顺序（\*natural ordering\*），也可以通过构造时传入的比较器**（*Comparator*，类似于C++的仿函数）。

Java中_PriorityQueue_实现了_Queue_接口，不允许放入`null`元素；其通过堆实现，具体说是通过完全二叉树（*complete binary tree*）实现的**小顶堆**

## 常用方法

|        方法        |                 功能                  |
| :----------------: | :-----------------------------------: |
|   add(Element e)   |             队尾添加元素              |
|      clear()       |             清空整个列队              |
| contains(Object o) | 检查是否包含当前参数元素,返回布尔类型 |
|     offer(E e)     |               添加元素                |
|       peek()       |        访问队首元素（不删除）         |
|       poll()       |        取出队首元素，（删除）         |
|  remove(Object o)  |         根据value删除指定元素         |
|       size()       |               返回长度                |
|     isEmpty()      |    判断队列是否为空，返回布尔类型     |

### add()和offer()

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素，只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回`false`。对于_PriorityQueue_这两个方法其实没什么差别

### element()和peek()

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回`null`。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，`0`下标处的那个元素既是堆顶元素。所以**直接返回数组`0`下标处的那个元素即可**

## PriorityQueue实现大堆小堆

PriorityQueue实际上是一个堆（不指定Comparator时默认为最小堆），通过传入自定义的Comparator函数可以实现大顶堆

```java
PriorityQueue<Integer> priorityQueue=new PriorityQueue<>(); //小顶堆，默认容量为11
PriorityQueue<Integer> priorityQueue1=new PriorityQueue<>(11, new Comparator<Integer>() {
	//大顶堆，容量为11
	@Override
	public int compare(Integer o1, Integer o2) {
		return o2-o1;
	}
});
```



