# 事务的定义及特性

## 定义

- Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断

- Redis事务的主要作用就是**串联多个命令防止别的命令插队**

## 特性

- 单独的隔离操作 

  事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断

- 没有隔离级别的概念 

  队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行

- 不完全保证原子性 

  事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 

## **redis为什么不支持回滚、不保证原子性**

+ 只有当被调用的Redis命令有语法错误时，这条命令才会执行失败（在将这个命令放入事务队列期间，Redis能够发现此类问题），或者对某个键执行不符合其数据类型的操作，这就意味着只有程序错误才会导致Redis命令执行失败，这种错误很有可能在程序开发期间发现，一般很少在生产环境发现
+ Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。对于Redis事务的这种行为，有一个普遍的反对观点，那就是程序有可能会有缺陷（bug）。但是，你应当注意到：事务回滚并不能解决任何程序错误。例如，如果某个查询会将一个键的值递增2，而不是1，或者递增错误的键，**那么事务回滚机制是没有办法解决这些程序问题的**
+ 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。这个原子操作，和关系型 DB 的原子性不太一样，它不能完全保证原子性

# 为什么要做成事务

- 解决并发的安全性问题

- 想想一个场景：有很多人有你的账户,同时去参加双十一抢购

- ## 事务冲突的问题


### 例子

- 一个请求想给金额减8000

- 一个请求想给金额减5000

- 一个请求想给金额减1000


![img](https://cdn.nlark.com/yuque/0/2022/jpeg/29671373/1659103107503-fdf60557-771f-4e47-a7c5-cb1d280c8621.jpeg)

## 悲观锁

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132109289.jpeg)

+ **悲观锁(Pessimistic Lock)**, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。**传统的关系型数据库里边就用到了很多这种锁机制**，比如**行锁**，**表锁**，**读锁**，**写锁**等，都是在做操作之前先上锁

## 乐观锁

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132109198.jpeg)

+ **乐观锁(Optimistic Lock)**, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**。Redis就是利用这种check-and-set机制实现事务的

# Redis中事务的使用

## Multi、Exec、discard

- 从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行

- 组队的过程中可以通过discard来放弃组队


![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132108949.png)

**案例**

| ![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132108406.jpeg)组队成功，提交成功 |
| ------------------------------------------------------------ |
| ![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132108997.jpeg)组队阶段报错，提交失败 |
| ![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132108648.jpeg)组队成功，提交有成功有失败情况 |

## 事务执行出现错误

+ 组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132108389.jpeg)

+ 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132109899.jpeg)

## WATCH key [key ...]

+ 在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务**执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断**

![img](https://raw.githubusercontent.com/feixue-altaaa/picture/master/pic/202303132109430.jpeg)

## unwatch

- 取消 WATCH 命令对所有 key 的监视

- 如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 

# redis事务实现原理

Redis事务实现的一个核心结构是**事务队列**，当服务器以事务状态运行时，针对于接收到的不同命令会有不同的操作

- 如果是`MULTI`、`EXEC`、`WATCH`和`DISCARD`其中的任意一个，服务器立刻执行
- 如果不是上述的四个命令，那么服务器就会将其放入到一个事务队列中，然后向服务器返回`QUEUED`恢复，表示命令已经入队，等待执行

其中，每个`RedisClient`通过`mstate`字段来标识自己的事务状态，而事务状态又包含一个**事务队列**和一个**计数器**，如下所示：

```java
typedef struct redsiClient{
    multiState mstate;  // 事务状态
}

typedef struct multiState{
    multiCmd *commands;   // 事务队列
    int count;            // 入队命令计数器
}

typedeef struct multiCmd{
    robj **args;  // 参数
    int argc;     // 参数数量
    struct redisCommand *cmd;   // 命令指针
}
```

+ 当服务器使用MULTI开启事务后，后续所有除了`MULTI`、`EXEC`、`WATCH`和`DISCARD`之外的命令都会进入到事务队列中。当执行`EXEC`时，服务器会遍历事务队列，执行队列中的所有命令，最后将命令执行的结果回复给客户端

## Redis事务特性

**原子性**

事务中的所有操作都会进入服务端暂存队列，进入该队列之前，会检查命令的合法性，但不会检查语法的合法性。

语法的合法性要在执行的时候才能体现出来，如果语法有问题，redis 会忽略该指令，但会继续执行剩余指令。

这里你可能会问了，这不满足原子性的要求啊。是的，这里是`伪原子性`

**redis 的作者认为，执行阶段的语法错误会在软件测试阶段提前暴露并修正；并且，redis 定位是快速响应的内存数据库，如果加入回滚能力，将会严重影响效率**

**隔离性**

redis 服务端命令是串行执行，因此，天然`具备隔离性`

**持久性**

这个依赖于 redis 服务端选择的持久化类型。如果你选择的是 RDB 持久化，丢失数据可能会多一些。如果你选择 AOF 或者 AOF/RDB 混合模式，丢失数据风险就小的多

如果选择有 `AOF` 的模式，并且参数 appendfsync = everysec 时，redis `具备持久性`；不过，需要注意的是，如果配置 no-appendfsync-on-rewrite = yes，在 BGSAVE 或者 AOF rewrite 期间也是`不具备持久化`的。

其他模式下，由于存在数据丢失风险，因此，`不具备持久化`能力

**一致性**

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的

“一致” ***指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据***。redis 通过谨慎的错误检测和简单的设计来`保证事务的一致性`

- 入队错误：如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么 redis 将拒绝执行这个事务。
- 执行错误：在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。
- 服务宕机：可以根据对应的持久化策略进行恢复，不会对事务一致性产生影响

# Redis 如何保证原子性来应对并发访问

在使用`Redis`时不可避免地会遇到并发访问的问题，比如多个用户同时下单，就会对缓存中的商品库存数据进行并发更新。一旦有了并发写操作，数据就会被修改，如果没有做好并发控制，就会导致数据被修改错误，影响到业务的正常使用。（例如秒杀场景下的超卖情况）

为了保证并发访问的正确性，`Redis`提供了两个方法，分别是**加锁**和**原子操作**

**原子操作**是指执行过程中保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样既保证了并发控制，还能减少对系统并发性能的影响

`Redis`加锁会有两个问题，一方面是加锁操作多，会降低系统的并发访问性能。另一方面Redis客户端加锁时，需要用到**分布式锁**，而这需要额外的存储系统来提供加解锁的操作

## 原子操作

并发控制针对的操作范围主要是数据修改操作。当有多个客户端对同一份数据执行`RMW`（Read-Modify-Write）操作时，我们就需要RMW操作涉及的代码以原子性方式执行。访问同一份数据的`RMW`操作代码，就叫做**临界区代码**。`RMW`操作即是指客户端要对数据做修改操作时所需要执行的步骤，即要先读取`Redis`中的内存数据到客户端中，然后在本地修改，最后写入到`Redis`服务中。而这部分操作就是指临界区的操作逻辑了

### Redis 的两种原子操作方法

为了实现并发控制要求的临界区代码互斥执行。Redis的原子操作采用了两种方法：

- 把多个操作在Redis中实现一个操作，也就是单命令操作；
- 把多个操作写到一个`Lua`脚本中，以原子性方式执行单个`Lua`脚本。

#### 单命令操作

虽然`Redis`的单个命令可以原子性执行，但实际操作中数据修改包含了多个命令的操作，包括数据读取、数据增减、写回数据三个操作。

这种情况就需要使用`Redis`提供的单命令操作了。例如`INCR/DECR`命令就可以实现数据的增减操作，而且因为它们本身就是单个命令操作，所以在执行它们时，就保证了它们的互斥性。

#### Lua脚本

如果只是简单的增减操作，那么就可以使用单命令保证其原子性了。但是可能会有更复杂的判断逻辑或者其它操作，那么就需要通过封装多个命令在`Lua`脚本执行操作了。

Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。但是如果把很多操作都放在 Lua 脚本中原子执行，会导致 Redis 执行脚本的时间增加，同样也会降低 Redis 的并发性能。所以在编写`Lua`脚本时需要避免把不需要做并发控制的操作写入脚本中

## 分布式加锁

在应对并发问题时，除了原子操作，Redis客户端可采用加锁的方法，来控制并发写操作对共享数据的修改，从而保证数据的正确性

当有多个客户端需要争抢锁时，需要保证的是这把锁不能是某个客户端本地的锁。否则的话，其它客户端的是无法访问到这把锁的，更不要说是获取锁了。所以在分布式系统中，当有多个客户端需要获取锁时，需要使用分布式锁。此时锁是保存在共享存储系统中的，可以被多个客户端共享访问和获取。

而`Redis`正好可以被多个客户端共享访问，可以保存分布式锁。

加锁操作和释放锁的操作就是针对锁的键值进行读取、判断、设置的过程。

- 加锁时根据锁变量值判断是否可以加锁，如果可以则对锁变量值进行修改，表示持有锁；
- 释放锁时同样需要进行判断，因为需要判断当前加锁的是不是该客户端，如果不判断直接释放锁的话，会被其它客户端将持有的锁给释放掉了；如果可以释放锁，则重置锁变量的值；

这样一来，因为加锁释放锁涉及了多个操作，所以实现分布式锁时需要两个保证：

- 锁操作的原子性；
- 分布式锁的可靠性；

### 锁操作的原子性

锁操作的原子性可以采用上面提到的单命令操作和`Lua`脚本操作。

#### 单命令操作和Lua脚本

使用 `SETNX` 和 `DEL`命令即可实现加锁和释放锁的操作。`SETNX`命令表示在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置。

```
SETNX key value
```

释放锁时直接将锁删除掉即可。

但进行操作时需要注意两个问题：

- 一是锁的过期时间设置；在加锁后，如果后面的逻辑发生了异常导致没有释放锁，这时就需要过期时间去保证该客户端不能一直持有锁。
- 还有一个是需要区别不同客户端的释放锁操作；这可以让每个客户端加锁时设置唯一值；

锁过期时间的设置和释放锁的操作都需要保证原子性；这里使用SET命令的NX选项 和Lua脚本保证了。

```
SET KEY VALUE [EX seconds | PX milliseconds] [NX]
```

即`SET lock_key unique_value NX PX 10000` 表示给lock_key这个键设置unique_value值，同时设置过期时间为10000ms。

释放锁也包含了读取锁变量值、判断锁变量值和删除锁变量三个操作，不过，我们无法使用单个命令来实现，所以，我们可以采用 Lua 脚本执行释放锁操作，通过 Redis 原子性地执行 Lua 脚本，来保证释放锁操作的原子性。

释放锁时的`Lua`脚本

```lua
//释放锁 比较unique_value是否相等，避免误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

### 分布式锁的可靠性

为了避免锁实例出现故障而导致的锁无法工作的问题，需要按照一定的步骤和规定。`Redis` 的开发者 Antirez 提出了分布式锁算法 `Redlock`

`RedLock`的基本思路是，是让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够与半数以上的实例成功地完成加锁操作，那么就认为客户端获得了分布式锁。这样一来，即使有某个Redis实例发生故障，那么也有其它实例可以做锁操作的支撑

客户端需要满足以下两个条件才能认为是加锁成功

- 客户端从超过半数（大于等于N/2 + 1)的Redis实例上成功获取到了锁
- 客户端获取锁的总耗时没有超过锁的有效时间

`RedLock`算法实现的可以分为3个步骤，假设需要有N个独立的Redis实例

- 客户端获取当前时间；
- 客户端按顺序依次向N个Redis实例执行加锁操作
  - 向Redis实例请求加锁，一样是采用SET NX 原子操作的命令，为了保障在加锁过程中Redis故障了，需要给加锁操作设置一个超时时间。如果超时了，那么会去下一个Redis实例继续请求加锁。
  - 加锁操作的超时时间需要远远小于锁的有效时间，一般也是设置几十毫秒。
- 一旦客户端完成了和所有Redis实例的加锁操作，客户端计算整个加锁过程的总耗时

在满足加锁成功的条件后，需要重新计算锁的有效时间，计算结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，那么就需要释放锁，以免出现还没完成数据操作，锁就过期的情况

